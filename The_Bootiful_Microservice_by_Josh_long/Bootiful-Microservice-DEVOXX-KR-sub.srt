1
00:00:00,000 --> 00:00:05,000
다들 안녕하세요! 제 세션에 와 주셔서 감사합니다.

2
00:00:05,180 --> 00:00:09,300
다들 여기 앉아 계시는 동안,

3
00:00:09,320 --> 00:00:12,140
시작하기 전에 뭔가 좀 중요한 일을 먼저 해야 겠어요

4
00:00:12,280 --> 00:00:14,320
제가 이 말을 하면,

5
00:00:14,960 --> 00:00:18,140
여러 분들은 "오픈 소스" 라고 말해 주겠어요?

6
00:00:18,240 --> 00:00:20,240
그럼 저는 그때 사진을 찍을 거에요

7
00:00:20,240 --> 00:00:21,960
오케이, 준비 됬나요?

8
00:00:21,960 --> 00:00:23,480
하나,

9
00:00:23,480 --> 00:00:24,820
둘,

10
00:00:24,820 --> 00:00:26,620
오픈 소스~~~

11
00:00:27,840 --> 00:00:30,680
아 예, 잘 나왔네요  고맙습니다. ㅎㅎ

12
00:00:33,740 --> 00:00:54,920
시작하기 전에 ~ [프랑스어를 구사하는 중]

13
00:00:54,940 --> 00:00:56,940
오케?

14
00:00:56,960 --> 00:01:06,760
[다시 프랑스어]

15
00:01:07,100 --> 00:01:09,580
제 이름은 Josh구요, 
[박수]

16
00:01:13,920 --> 00:01:15,920
저에 대해서 간단히 소개하자면

17
00:01:15,920 --> 00:01:18,960
제 이름은 Josh Long 이구요, 와 주셔서 감사하구요 저도 여기 있게 되어 행복합니다.

18
00:01:19,080 --> 00:01:21,080
이 세션동안 엄청나게 많은 양의 코드를 살펴보게 될겁니다.

19
00:01:21,340 --> 00:01:23,880
코드는 오늘날 우리가 서로 대화 할 수 있는 방법이죠

20
00:01:23,880 --> 00:01:25,600
코드는 매우 중요합니다.

21
00:01:25,800 --> 00:01:27,800
지구에 있는 약 80억명의 사람들

22
00:01:27,800 --> 00:01:29,440
추정치죠?

23
00:01:29,440 --> 00:01:31,680
그중 절반의 사람들이 인터넷을 사용하고 있습니다.

24
00:01:31,680 --> 00:01:33,960
그 사람들에게 코드는 매우 강력한 도구죠

25
00:01:34,000 --> 00:01:36,140
코드는 매우 중요하죠. 위에 보이는 URL을 복사해 두세요.

26
00:01:36,140 --> 00:01:37,920
그럼 이제 시작 합시다

27
00:01:37,920 --> 00:01:39,400
다시 약간 제 이야기를 하자면

28
00:01:39,400 --> 00:01:41,160
저는 스프링 개발 advocate이구요,

29
00:01:41,160 --> 00:01:43,140
피보탈의 스프링팀에 소속 되어 있기도 하고,

30
00:01:43,340 --> 00:01:45,660
작지만 큰 꿈을 가지고 있는 회사구요

31
00:01:45,660 --> 00:01:47,080
큰 꿈이요

32
00:01:47,700 --> 00:01:49,700
책도 쓰고 있습니다.

33
00:01:49,700 --> 00:01:51,500
이제 5권 째가 되는데요

34
00:01:51,540 --> 00:01:53,460
오픈 소스에 코드를 기여하고 있기도 합니다.

35
00:01:53,460 --> 00:01:54,980
제가 일등 하는게 있는데,

36
00:01:55,120 --> 00:01:56,220
일등이요

37
00:01:56,220 --> 00:01:57,560
일등으로 기여하는 거

38
00:01:57,560 --> 00:01:59,160
바로 '버그' 입니다.

39
00:01:59,360 --> 00:02:00,840
버그를 1등으로 생산하고 있어요!

40
00:02:00,840 --> 00:02:02,780
7년동안,

41
00:02:02,920 --> 00:02:04,380
1등!

42
00:02:08,480 --> 00:02:10,480
많은 위대한 오픈소스 프로젝트들이 있죠

43
00:02:10,780 --> 00:02:13,840
이게 제가 주로 하는 일이구요,

44
00:02:13,960 --> 00:02:16,260
트레이닝을 위한 비디오도 찍고 있습니다.

45
00:02:16,760 --> 00:02:18,720
동시에 저는 '자바 챔피언'이기도 한데요,

46
00:02:18,720 --> 00:02:21,040
이건 스프링 개발자 advocate이랑 비슷한건데,

47
00:02:21,180 --> 00:02:24,300
커뮤티니 멤버들 앞에서 발표를 하거나

48
00:02:24,380 --> 00:02:27,500
여러분들 처럼 훌륭한 청중 앞에서 발표 하기도 합니다.

49
00:02:27,600 --> 00:02:29,800
지금 하고 계신것에 열정이 있는 분들이죠

50
00:02:29,900 --> 00:02:34,200
또 저는 저희 피보탈이 하는 일에 대해서도 발표하곤 합니다.

51
00:02:34,300 --> 00:02:37,660
우리 피보탈에는 굉장히 많은 오픈소스 소프트웨어가 있어요

52
00:02:37,860 --> 00:02:39,860
그리고 이 오픈 소스 소프트웨어가 바로

53
00:02:40,020 --> 00:02:44,260
이건 우리가 아침에 일어나는 이유이자

54
00:02:44,260 --> 00:02:46,060
우리가 열광하는 대상이기도 합니다.

55
00:02:46,160 --> 00:02:48,820
그리고 우린 출근해서, "이제부터 오픈소스 할거야" 하고 외치죠

56
00:02:49,020 --> 00:02:52,660
우리는 사람들이 빠르게,

57
00:02:52,660 --> 00:02:54,280
오~예~ [사진 찍는 사람에게 포즈 취해주는 중]

58
00:02:54,560 --> 00:02:59,920
우리는 사람들이 빠르게 컨셉을 프로덕션으로 만들어 낼 수 있도록 돕는 일을 합니다.

59
00:03:00,040 --> 00:03:02,320
컨셉을 프로덕션으로

60
00:03:02,320 --> 00:03:03,860
대부분의 조직들은

61
00:03:04,060 --> 00:03:08,640
대부분의 조직들은 소프트웨어 공장을 조직 안에 운용하고 있습니다.

62
00:03:08,820 --> 00:03:13,600
이 소프트웨어 공장에는 프로덕트 매니저로 부터,

63
00:03:13,720 --> 00:03:16,720
사용자 경험, 개발자들, 테스터들,

64
00:03:16,880 --> 00:03:19,840
서버 어드민, 데이터베이스 어드민,

65
00:03:19,840 --> 00:03:22,380
보안, SAN, 네트워크  등등등

66
00:03:22,480 --> 00:03:25,000
이 많은 사람들의 수많은 조직을 지나는 프로세스를 살펴 보면

67
00:03:25,000 --> 00:03:26,360
이건 '영원'이라고 부를 정도로

68
00:03:26,520 --> 00:03:29,220
컨셉에서 프로덕션 까지 가는데 영원의 시간이 걸립니다.

69
00:03:29,660 --> 00:03:33,760
하지만 지금 우리가 살고있는 2016년에선

70
00:03:33,880 --> 00:03:36,700
소프트웨어가 모든것을 바꾸고 있습니다.

71
00:03:37,180 --> 00:03:39,600
'느리게' 는 더 이상 선택해야할 옵션이 아닙니다.

72
00:03:39,600 --> 00:03:41,120
여러분은 빨리 움직여야 해요

73
00:03:41,120 --> 00:03:42,800
근데 이런 소프트웨어 파워는 사방에서 관찰할 수 있어요

74
00:03:42,880 --> 00:03:45,700
지금 세계에서 1등 하는 택시 회사는 뭔지요?

75
00:03:45,700 --> 00:03:46,820
[누군가 대답]
우버

76
00:03:46,900 --> 00:03:47,620
고맙습니다.

77
00:03:47,620 --> 00:03:49,800
오늘날 세계에서 1등하는 호텔 회사는 뭐지요?

78
00:03:49,800 --> 00:03:50,860
[누군가 대답]
에어비엔비

79
00:03:50,900 --> 00:03:54,640
현재 성장율이 1등... 그 성장율 기준에서..

80
00:03:54,820 --> 00:03:57,600
오늘날 1등하는 자동차 회사는 뭔가요

81
00:03:58,860 --> 00:03:59,380
테슬라?

82
00:03:59,380 --> 00:04:00,280
예 맞아요, 테슬라

83
00:04:00,720 --> 00:04:03,940
음 그 1등하는 어...

84
00:04:04,500 --> 00:04:06,500
비디오 대여 서비스는 뭐죠?

85
00:04:06,500 --> 00:04:07,700
[누군가 대답]
넷플릭스

86
00:04:07,740 --> 00:04:08,800
고맙습니다.

87
00:04:08,900 --> 00:04:12,240
이 회사들은 처음 사업을 시작할때, 엄청나게 많은 돈을 가지진 않았어요

88
00:04:12,440 --> 00:04:15,200
사람이 많았던 것도 아니에요

89
00:04:15,200 --> 00:04:16,540
그렇지만 이들은 다  '빠른 속도'를 가지고 있었어요.

90
00:04:16,800 --> 00:04:19,760
그들은 '애자일' 을 가져야 했어요

91
00:04:20,080 --> 00:04:23,040
그래서 그들은 더 많이 실수하고, 빨리 복구하고,

92
00:04:23,040 --> 00:04:24,680
그래서 남들보다 더 빠를 수 있었죠

93
00:04:24,680 --> 00:04:26,460
그래서 그들은 지금 그냥 1등이 아니라

94
00:04:26,460 --> 00:04:28,440
1등 이상의 그,

95
00:04:28,440 --> 00:04:32,100
영어에서는 우린 이걸 "시장을 파괴한다"고 하죠

96
00:04:32,260 --> 00:04:34,260
전 세계에서요

97
00:04:34,260 --> 00:04:36,220
그리고 비슷한 경쟁사들을 다 죽이고 있어요

98
00:04:36,220 --> 00:04:38,140
그리고 완전 새로운 영역을 만들어 내죠

99
00:04:38,140 --> 00:04:39,860
여기에 바로 '속도'가 매우 중요한 겁니다.

100
00:04:39,940 --> 00:04:42,780
그래서 이런 조직들은 '빨라'지는 방법을 찾고 있지요

101
00:04:42,840 --> 00:04:45,880
그들은 0에서 시작해서 끝까지 빠르게 가는 방법을 찾고 있어요

102
00:04:45,940 --> 00:04:47,940
아이디어가 있으면

103
00:04:47,940 --> 00:04:49,320
빨리 구현해야 해요

104
00:04:49,320 --> 00:04:52,120
그래서 이런 조직들은 작은,

105
00:04:52,220 --> 00:04:53,860
작은 기능을 하는 작은 부분으로 만들어 내는데

106
00:04:53,860 --> 00:04:55,820
여러분들이 완전 집중할 수 있는

107
00:04:55,960 --> 00:04:58,300
전체 애플리케이션에 대한 변경을 생각하는 대신

108
00:04:58,720 --> 00:05:01,800
아주 작은 기능의 세트를

109
00:05:01,880 --> 00:05:03,880
그리고 이 작은 기능의 세트에 집중 함으로서

110
00:05:03,880 --> 00:05:05,420
더 빨라질 수 있는 것이죠

111
00:05:05,460 --> 00:05:09,440
애플리케이션을 각각 작은 부분으로 나눠 내는 것이 핵심이고

112
00:05:09,580 --> 00:05:12,340
애플리케이션 안에서 거대한 부분 대신

113
00:05:12,440 --> 00:05:16,280
작은 부분들을 독립적으로 개선하고, 개발 하는 것이죠

114
00:05:16,300 --> 00:05:18,300
이 작은 기능을 하는 서비스를

115
00:05:18,300 --> 00:05:19,900
바로 "마이크로 서비스" 라고 부릅니다.

116
00:05:19,900 --> 00:05:21,500
마이크로 서비스는

117
00:05:21,560 --> 00:05:24,680
조직이 '속도'를 가질 수 있도록 돕기도 하는데

118
00:05:25,100 --> 00:05:27,340
이건 무슨 런타임의 확장에 대한 이야기가 아니에요

119
00:05:27,420 --> 00:05:30,920
물론, 여러분은 더 많은 요청을 처리 할 수 있겠지만

120
00:05:30,920 --> 00:05:32,460
그리고 더 많은 사용자를 처리하고

121
00:05:32,460 --> 00:05:34,120
하지만 그게 지금 목적은 아닌거죠

122
00:05:34,320 --> 00:05:37,200
세상의 대부분의 사람들은 넷플릭스나 구글이 아니에요

123
00:05:37,420 --> 00:05:41,880
더 많은 사용자를 받기 위해서 이런 아키텍처로 변환할 필요가 있는건 아니에요

124
00:05:42,260 --> 00:05:45,220
마이크로 서비스를 하는 이유는 더 "빨라"지기 위해서고

125
00:05:45,520 --> 00:05:46,860
하나의 팀은 이거에 집중하고

126
00:05:46,860 --> 00:05:48,180
다른 팀은 저거에 집중함으로서

127
00:05:48,240 --> 00:05:51,580
서로 일을 하기 위해서 팀간에 동기화가 필요 없어지는 거죠

128
00:05:51,580 --> 00:05:52,620
그쵸?

129
00:05:52,680 --> 00:05:54,980
그래서 조직들은 더 빨라지는 방법을 찾게 되구요

130
00:05:55,120 --> 00:05:57,720
그래서 마이크로 서비스 아키텍처를 선택하게 되고

131
00:05:57,720 --> 00:05:58,800
근데 문제는

132
00:05:58,960 --> 00:06:01,240
아주 빨리 직면하는 2가지 문제가 있는데

133
00:06:01,240 --> 00:06:03,140
첫번째 문제는 바로,

134
00:06:03,140 --> 00:06:05,140
"나는 새로운 서비스를 만들고 싶어"

135
00:06:05,140 --> 00:06:06,340
예를 들어 "나는, 여기에 새로운 서비스,

136
00:06:06,340 --> 00:06:06,840
여기에 새로운 서비스,

137
00:06:06,840 --> 00:06:07,440
고기에 새 서비스

138
00:06:07,460 --> 00:06:08,440
죠기에 새로운 서비스

139
00:06:09,040 --> 00:06:11,520
거의 대부분의 조직에서 제가 확신하건데,

140
00:06:11,600 --> 00:06:13,800
여러분이 이런 조직에서 일하실리는 별로 없겠지만

141
00:06:13,940 --> 00:06:16,900
아마도 거기서 일하는 누군가를 아실지도 모르겠고

142
00:06:16,980 --> 00:06:18,980
아무튼 이런 형태의 조직에서는 보통

143
00:06:18,980 --> 00:06:21,600
엄청난 분량의 끔찍한 위키 페이지가 있어요

144
00:06:21,880 --> 00:06:23,880
500줄로 구성된 "쉬운 따라하기 방법"

145
00:06:23,880 --> 00:06:25,560
프로덕션에 소프트웨어를 배포하는 방법.

146
00:06:25,560 --> 00:06:26,460
그쵸?

147
00:06:26,660 --> 00:06:29,460
이 경우 그 위키 페이지는 '속도'의 적 입니다.

148
00:06:29,460 --> 00:06:30,940
이건 사실 무섭구요

149
00:06:30,940 --> 00:06:32,300
새로운 서비스를 만들때도

150
00:06:32,300 --> 00:06:33,660
그래서 올바른 일을 해야 하는거에요

151
00:06:33,700 --> 00:06:36,260
만약 여러분이 이런 상황에 처해 있다면, 이런 느린 것들을 없애야 합니다.

152
00:06:36,280 --> 00:06:38,280
그래서 저는 오늘 여러분들께

153
00:06:38,300 --> 00:06:39,360
"스프링 부트"

154
00:06:39,360 --> 00:06:40,800
혹시 "스프링 부트" 들어본 분 계세요?

155
00:06:41,700 --> 00:06:42,320
어~~~

156
00:06:42,320 --> 00:06:43,840
전부 다 들어보신건 아니네요.

157
00:06:44,600 --> 00:06:45,840
그건 어...

158
00:06:46,060 --> 00:06:48,860
음 물론 대부분 들어 보신 것은 맞지만, 모두는 아니에요.

159
00:06:49,620 --> 00:06:51,620
이 문제를 오늘 고쳐버립시다.

160
00:06:52,920 --> 00:06:54,240
첫번째 문제를 해결하고 나면,

161
00:06:54,380 --> 00:06:57,480
그리고 두번째, 그 소프트웨어를 빨리 만들고 나면

162
00:06:57,640 --> 00:06:59,640
이제 여러분은 분산 컴퓨팅으로 진입하게 됩니다.

163
00:06:59,780 --> 00:07:02,620
아주 많은 서비스들이 서로 통신해야 할 필요가 있을 거에요

164
00:07:02,820 --> 00:07:05,500
이런게 바로 분산 컴퓨팅이고, 이 역시 잘 구성해야 합니다.

165
00:07:05,500 --> 00:07:07,440
그래서 우린 "스프링 클라우드"

166
00:07:07,440 --> 00:07:08,860
를 이런 부분의 해결 방법으로 사용할 거에요.

167
00:07:08,860 --> 00:07:09,720
이제

168
00:07:09,880 --> 00:07:11,960
이 세션은 엄청나게 빨리 진행될 겁니다.

169
00:07:12,560 --> 00:07:13,500
그니까...

170
00:07:15,040 --> 00:07:17,040
꽉 붙들고 따라 오세용

171
00:07:17,040 --> 00:07:18,200
37분 남았네요

172
00:07:18,200 --> 00:07:19,620
제가 다 할 수 있을지 모르겠지만,

173
00:07:19,620 --> 00:07:20,820
시도해 볼 수는 있죠

174
00:07:21,080 --> 00:07:23,080
여기까지가 제 슬라이드 구요. 맘에 드시나요?

175
00:07:23,760 --> 00:07:25,760
이거 만드느라 시간 좀 썼어요.

176
00:07:26,280 --> 00:07:28,640
여러분 모두 이 화면이 잘 보이시는지 모르겠네요.

177
00:07:28,640 --> 00:07:29,860
좋습니다!

178
00:07:29,860 --> 00:07:31,400
우린 START.SPRING.IO 에서 시작합니다.

179
00:07:31,680 --> 00:07:34,540
여기는 제가 인터넷에서 두번째로 좋아하는 장소인데요.

180
00:07:34,540 --> 00:07:36,340
첫번째로 좋아하는 장소는,

181
00:07:36,340 --> 00:07:37,780
당연하지만, '프로덕션' 이죠.

182
00:07:37,780 --> 00:07:39,640
프로덕션으로 가는게 최고입니다.

183
00:07:39,640 --> 00:07:41,160
프로덕션으로 갈 수만 있다면,

184
00:07:41,160 --> 00:07:41,940
그러셔야 하구요

185
00:07:41,940 --> 00:07:43,140
애들도 데려 오시고,

186
00:07:43,140 --> 00:07:44,340
여러분의 가족도 데려가고

187
00:07:44,340 --> 00:07:45,800
프로덕션은 그정도로 놀랍습니다.

188
00:07:45,800 --> 00:07:47,400
디즈니 랜드보다 좋구요

189
00:07:47,400 --> 00:07:48,600
저는 프로덕션을 사랑합니다.

190
00:07:48,600 --> 00:07:49,980
여러분도 그러시길 바래요.

191
00:07:49,980 --> 00:07:50,620
하지만

192
00:07:50,620 --> 00:07:52,180
여러분이 프로덕션에 아직 못가셨다면

193
00:07:52,280 --> 00:07:55,760
그렇다면 START.SPRING.IO 에 가세요

194
00:07:55,760 --> 00:07:57,300
만약 여러분이 슬픈 상태라면,

195
00:07:57,300 --> 00:07:58,820
그리고 뭔가 영감을 받았다면

196
00:07:59,180 --> 00:07:59,900
START

197
00:08:00,260 --> 00:08:01,260
.SPRING

198
00:08:01,820 --> 00:08:02,420
.IO

199
00:08:03,940 --> 00:08:06,520
여러분이 만약 밤에 잠들지 못한다면

200
00:08:06,520 --> 00:08:07,920
START

201
00:08:07,920 --> 00:08:08,940
.SPRING

202
00:08:08,940 --> 00:08:10,000
.IO

203
00:08:10,880 --> 00:08:13,180
여기는 새로운 애플리케이션을 만들고자 할때 아주 좋은 곳이에요

204
00:08:13,240 --> 00:08:15,240
그래서 이 사이트에서 새로운 서비스를 만들어 볼겁니다.

205
00:08:15,240 --> 00:08:17,200
서비스의 이름은 "예약 서비스" 구요

206
00:08:17,200 --> 00:08:18,820
Web support 를 추가하고,

207
00:08:18,960 --> 00:08:22,060
H2 인메모리 데이터베이스를 추가하고

208
00:08:22,060 --> 00:08:24,040
JPA 도 추가하고

209
00:08:24,680 --> 00:08:26,680
왜냐 하면 저는 인생에서 끔찍한 결정을 잘 하니까요,

210
00:08:26,680 --> 00:08:27,640
JPA,

211
00:08:27,680 --> 00:08:29,680
그리고 Actuator (액츄에이터)도 추가하고,

212
00:08:29,680 --> 00:08:31,540
Config client 와

213
00:08:31,540 --> 00:08:32,740
Eureka (유레카), RabbitMQ

214
00:08:32,740 --> 00:08:34,000
스트림 프로세싱,

215
00:08:34,000 --> 00:08:35,700
그리고 Zipkin 분산 추적

216
00:08:35,700 --> 00:08:36,980
이게 다 입니다.

217
00:08:37,660 --> 00:08:40,580
아, 맞네요 REST 레포지트리

218
00:08:40,740 --> 00:08:42,740
네 지금 추가 합니다.

219
00:08:42,740 --> 00:08:44,180
아 그리고 저는

220
00:08:44,280 --> 00:08:47,140
제가 원한다면 몇가지 세부 항목을 결정할 수 있는데요

221
00:08:47,220 --> 00:08:49,220
여기서 저는 패키징의 방법을 선택할 수 있습니다.

222
00:08:49,620 --> 00:08:51,620
어떤 분들은 이거 선택에 무지 헛갈려 하시는데

223
00:08:51,700 --> 00:08:53,700
어떤걸 선택해야 하는지 말이죠

224
00:08:53,880 --> 00:08:56,440
시간이 얼마 없으니까 매우 빨리 설명하도록 하겠습니다.

225
00:08:56,440 --> 00:08:57,340
만약

226
00:08:57,440 --> 00:08:59,720
여러분이 매우 아주 아주 먼

227
00:08:59,720 --> 00:09:01,440
끔찍하게 오래된 과거에 살고 있다면

228
00:09:01,940 --> 00:09:03,940
무지무지 오래된,

229
00:09:04,440 --> 00:09:06,440
그렇다면 반드시

230
00:09:06,440 --> 00:09:08,080
.WAR 를 선택하세요

231
00:09:08,740 --> 00:09:10,740
하지만 만약 여러분이 지금 여기,

232
00:09:11,560 --> 00:09:12,760
저와 함께

233
00:09:13,760 --> 00:09:16,100
2016년에 살고 계신다면

234
00:09:16,800 --> 00:09:18,800
그렇다면

235
00:09:18,800 --> 00:09:19,740
.JAR를 선택하세요.

236
00:09:20,120 --> 00:09:23,320
이건 저의 개인적인 철학의 매우 큰 부분이기도 한데

237
00:09:23,540 --> 00:09:25,540
JAR를 만들되, WAR는 안된다. 
(make JAR not WAR)

238
00:09:25,540 --> 00:09:26,760
다시, 여러분들은 옵션이 있어요

239
00:09:26,760 --> 00:09:27,980
선택하실 수 있죠

240
00:09:28,140 --> 00:09:30,140
그 선택은, 여러분을 위해 실제로 동작하는걸 고르시면 됩니다.

241
00:09:30,140 --> 00:09:31,780
동작하는걸 선택하세요.

242
00:09:31,780 --> 00:09:32,960
좋네요

243
00:09:32,960 --> 00:09:34,060
오예

244
00:09:34,060 --> 00:09:35,160
자 이제,

245
00:09:35,200 --> 00:09:38,560
선택을 했구요, 이제 "새로운 서비스를 생성" 버튼을 누릅니다.

246
00:09:38,880 --> 00:09:41,160
그러면 여러분이 사용할 수 있는 ZIP 파일이 다운로드 되구요

247
00:09:41,160 --> 00:09:43,120
사용하시는 IDE로

248
00:09:43,220 --> 00:09:46,000
웁스, 다시 받아야 겠네요. 어쨌든 사용하는 IDE로

249
00:09:46,000 --> 00:09:47,500
이클립스 사용하시는 분?

250
00:09:47,500 --> 00:09:48,720
이클립스요?

251
00:09:48,720 --> 00:09:50,060
좋아요! 저도 이클립스 사랑합니다.

252
00:09:50,060 --> 00:09:51,800
넷빈즈 사용하시는 분?

253
00:09:51,800 --> 00:09:53,420
좋네요! 넷빈즈도 사랑해요

254
00:09:53,540 --> 00:09:56,700
왜냐 하면 두 도구 모두 스프링 툴을 가지고 있기 때문이죠

255
00:09:56,700 --> 00:09:58,180
인텔리제이 사용하시는 분?

256
00:09:58,180 --> 00:09:59,380
오! 와우!

257
00:09:59,380 --> 00:10:01,200
와우 좋아요 좋아

258
00:10:01,200 --> 00:10:03,120
어, 그 혹시 여기도 오셨나요? 계세요?

259
00:10:03,120 --> 00:10:04,820
emacs 쓰시는 분?

260
00:10:04,820 --> 00:10:06,340
계세요?

261
00:10:06,340 --> 00:10:07,640
아 안보이네요.

262
00:10:07,640 --> 00:10:08,940
안보여요

263
00:10:09,000 --> 00:10:11,380
그분은 제가 가는 모든 대륙, 모든 나라에 오시는데

264
00:10:11,940 --> 00:10:13,280
어떻게인진 모르구요

265
00:10:13,680 --> 00:10:15,680
같은거에요

266
00:10:18,860 --> 00:10:19,840
몰라요

267
00:10:20,320 --> 00:10:23,100
아 좋습니다. 저는 이제 아주 간단한 서비스를 만들 거에요

268
00:10:23,280 --> 00:10:26,600
설명할 시간이 별로 없으니까 빨리 할게요.

269
00:10:27,320 --> 00:10:28,460
자 이제 하아~

270
00:10:30,900 --> 00:10:33,300
"예약 서비스" 애플리케이션

271
00:10:33,360 --> 00:10:36,520
모두들 잘 보실 수 있게 폰트 크기를 좀 조정할께요

272
00:10:36,520 --> 00:10:37,820
여기서 이렇게

273
00:10:37,960 --> 00:10:40,660
보이죠? [더 크게 프로파일이 있음]

274
00:10:41,540 --> 00:10:42,520
오케?

275
00:10:43,000 --> 00:10:44,020
시작합시다

276
00:10:44,880 --> 00:10:45,860
이제

277
00:10:46,540 --> 00:10:48,520
여기 public static void main 이 있습니다.

278
00:10:48,600 --> 00:10:50,940
이제 Entity 타입 Reservation 을 만들거구요

279
00:10:50,960 --> 00:10:53,680
JPA 엔티티이며, @Entity 를 사용합니다.

280
00:10:53,680 --> 00:10:54,780
요렇게요

281
00:10:54,880 --> 00:10:57,580
그리고 Primary Key 를 이렇게 만들구요

282
00:10:57,580 --> 00:10:59,460
private Long id 를 넣고

283
00:10:59,580 --> 00:11:02,600
다른 필드로 reservationName 을 추가 합니다.

284
00:11:02,920 --> 00:11:07,540
이 필드는 데이터베이스에서 요렇게 컬럼이 될 거에요

285
00:11:07,720 --> 00:11:12,460
그리고 @Id 와 @GenerateValue 를 추가 합니다.

286
00:11:12,520 --> 00:11:15,640
지금 보시는게 바로 순수한 도메인 모델 입니다.

287
00:11:15,640 --> 00:11:17,420
엑기스구요

288
00:11:17,860 --> 00:11:19,860
우리 도메인의 기본이 됩니다.

289
00:11:20,080 --> 00:11:22,480
아주 순수하고, 아주 깨끗하죠.

290
00:11:22,680 --> 00:11:24,680
무지 깨끗합니다.

291
00:11:25,300 --> 00:11:27,980
근데 이건 자바죠. 이걸로만은 충분하지 않아요.

292
00:11:28,120 --> 00:11:30,200
엄청 많은 것들을 더 추가해 줘야 해요

293
00:11:30,200 --> 00:11:32,040
[컨스트럭터 등을 추가] [웃음]

294
00:11:32,120 --> 00:11:33,060
그쵸?

295
00:11:33,240 --> 00:11:35,240
왜? 왜때문에 JPA를?

296
00:11:39,480 --> 00:11:44,840
[프랑스어로 다시 쓰는 중]

297
00:11:44,960 --> 00:11:46,960
챱챱

298
00:11:46,960 --> 00:11:48,920
나 이거 할 수 있어

299
00:11:48,920 --> 00:11:50,320
됬네요

300
00:11:50,820 --> 00:11:52,820
완성 했습니다.

301
00:11:53,060 --> 00:11:55,060
[박수]

302
00:11:55,060 --> 00:11:56,640
[알 수 없는 말을 한다]

303
00:11:56,800 --> 00:12:01,620
[스페인어를 추가 중]

304
00:12:02,000 --> 00:12:08,900
[무언가 또 다른 언어]

305
00:12:09,720 --> 00:12:11,720
어쨌든,

306
00:12:11,880 --> 00:12:14,180
더 진행하면, toString 이 필요하구요, 여기 있죠

307
00:12:14,420 --> 00:12:16,940
자 이제 날짜를 데이터베이스에 저장할거에요

308
00:12:16,940 --> 00:12:18,500
여기에 레포지트리를 생성할거구요

309
00:12:18,640 --> 00:12:20,800
이건 dumb 오브젝트 입니다

310
00:12:20,940 --> 00:12:25,620
이건 에릭 에반스 박사가 주창한 레포지트리 개념인데

311
00:12:25,620 --> 00:12:27,460
이건 뭔가를 핸들링 하는

312
00:12:27,600 --> 00:12:31,680
지루한 데이터베이스 읽기 쓰기 작업을

313
00:12:31,680 --> 00:12:32,560
별로 흥미롭지는 않은 부분인데

314
00:12:32,660 --> 00:12:35,680
아무도 금요일 밤에 여러분에게 와서

315
00:12:35,820 --> 00:12:38,580
여러분의 어깨에 손을 올린다음 말하길,

316
00:12:38,580 --> 00:12:39,780
"잘했어!!"

317
00:12:40,020 --> 00:12:42,560
"엄청나게 훌륭한 일을 했어"

318
00:12:42,720 --> 00:12:46,940
SELECT * foo where id = ?" 를 코딩했기 때문이지!!!

319
00:12:46,940 --> 00:12:48,020
아무도 상관하지 않아요

320
00:12:48,020 --> 00:12:49,240
그러니까 코드를 쓰지 말구요

321
00:12:49,260 --> 00:12:51,400
이런건 기계가 하도록 내버려 둡시다

322
00:12:51,400 --> 00:12:52,480
저한테는 요 인터페이스가 있는데요

323
00:12:52,660 --> 00:12:55,560
REST API 를 만들기 위한 이런 어노테이션이 있구요

324
00:12:55,560 --> 00:12:56,660
끝났어요

325
00:12:56,660 --> 00:12:58,280
컴퓨터가 하게 놔 두는 겁니다.

326
00:12:58,540 --> 00:13:00,900
이건 id 를 키로 찾기,

327
00:13:00,900 --> 00:13:02,240
저장하기, 지우기 등등을 제공 합니다.

328
00:13:02,400 --> 00:13:03,100
그쵸?

329
00:13:03,300 --> 00:13:05,500
자 이제 샘플 데이터가 필요한데요

330
00:13:06,100 --> 00:13:08,100
오브젝트를 생성할건데

331
00:13:08,100 --> 00:13:09,600
커맨드 라인 러너구요

332
00:13:09,740 --> 00:13:13,080
DummyCLR implements CommandLineRunner

333
00:13:13,560 --> 00:13:16,560
그리고 이제, 커맨드라인 러너는 콜백 입니다.

334
00:13:16,620 --> 00:13:19,980
스프링 부트 애플리케이션이 시작할때, 이건 run()을 호출할 거에요

335
00:13:20,160 --> 00:13:22,680
이건 여기에 있는 args 를 호출 합니다.

336
00:13:22,960 --> 00:13:26,880
그래서 저는 이 오브젝트를 데이터베이스에 넣을 수 있게 됩니다.

337
00:13:26,920 --> 00:13:29,800
여기에 저는 private final reservationRepository

338
00:13:29,980 --> 00:13:32,100
컨스트럭터를 생성하고

339
00:13:32,220 --> 00:13:34,900
스프링에게 컨스트럭터를 내 놓으라고 합니다

340
00:13:35,040 --> 00:13:37,080
지금 보신게 이런 종류의 일을 올바르게 처리하는 방법이에요

341
00:13:37,080 --> 00:13:38,840
여러분은 언제나 이렇게 해야 합니다.

342
00:13:39,100 --> 00:13:41,700
잘못된 예는 바로 이렇게 하시는 거죠

343
00:13:41,700 --> 00:13:43,660
여러분이 이렇게 코드를 쓸 때마다

344
00:13:43,660 --> 00:13:45,400
유닛 테스트가 죽어버릴 겁니다.

345
00:13:45,400 --> 00:13:46,660
항상 죽죠

346
00:13:46,660 --> 00:13:48,240
맨날 죽어요

347
00:13:48,240 --> 00:13:50,020
[박수]

348
00:13:50,040 --> 00:13:52,040
자 이제 여기서

349
00:13:52,040 --> 00:13:53,320
스트림

350
00:13:53,320 --> 00:13:55,320
of

351
00:13:56,480 --> 00:13:59,660
제 친구인 스펜서,

352
00:13:59,660 --> 00:14:00,600
마크,

353
00:14:03,920 --> 00:14:08,400
스테판,

354
00:14:09,340 --> 00:14:11,340
또 누가 있더라

355
00:14:12,060 --> 00:14:13,380
ㅎㅎㅎㅎ

356
00:14:16,460 --> 00:14:18,460
아나우드,

357
00:14:18,640 --> 00:14:20,640
안토니오

358
00:14:21,960 --> 00:14:25,000
이건 딱이네요

359
00:14:25,020 --> 00:14:27,020
짝수죠, 6.

360
00:14:27,340 --> 00:14:29,340
7이 아니구요,

361
00:14:29,340 --> 00:14:30,660
오늘 밤에 잘 잠들고 싶어요  [홀수는 뭔가 불안하다는]

362
00:14:30,960 --> 00:14:33,360
그래서 아름다운 짝수로 두고,

363
00:14:33,480 --> 00:14:37,020
foreach 를 사용해서 데이터베이스에 이렇게 저장 합니다.

364
00:14:37,640 --> 00:14:42,460
그리고 각각의 내용을 출력 합니다.

365
00:14:42,460 --> 00:14:43,360
그리고

366
00:14:43,360 --> 00:14:44,480
println 을 쓰죠

367
00:14:44,480 --> 00:14:46,320
이 스프링 부트를 구동하게 되면

368
00:14:46,400 --> 00:14:48,980
데이터베이스 안에는 데이터가 저장 될 겁니다.

369
00:14:48,980 --> 00:14:50,920
실제로 그런지 실행해 보도록 합시다.

370
00:14:53,880 --> 00:14:54,640
그쵸?

371
00:14:57,740 --> 00:14:58,980
어디지

372
00:14:59,480 --> 00:15:00,380
헬로?

373
00:15:00,380 --> 00:15:01,240
오

374
00:15:02,000 --> 00:15:03,300
요기 있네요

375
00:15:03,680 --> 00:15:06,280
이게 생성된 데이터들 입니다. 데이터베이스 안에 있구요

376
00:15:06,280 --> 00:15:07,540
당연하죠 이거 잘 동작합니다.

377
00:15:07,540 --> 00:15:09,260
데모잖아요

378
00:15:09,620 --> 00:15:11,620
실패를 바랬나요?

379
00:15:11,780 --> 00:15:14,880
대신, 조금 더 중요한걸 이야기 해 보도록 합시다.

380
00:15:15,820 --> 00:15:17,340
지금 보시는거 이거

381
00:15:17,940 --> 00:15:19,940
이건 훌륭한 아스키 작업이죠

382
00:15:21,000 --> 00:15:25,120
우리 스프링 팀에는 이걸 위해서 힘들게 작업하는 사람들이 있어요

383
00:15:25,580 --> 00:15:27,000
무지 힘들게 일하죠

384
00:15:27,480 --> 00:15:30,540
엄청 좋은데, 그리고 저는 인텔리제이의 엄청난 팬이지만,

385
00:15:30,540 --> 00:15:31,660
잠깐 이야기를 하자면

386
00:15:31,760 --> 00:15:34,640
제가 버그라고 생각하는 기능이 있어요

387
00:15:35,040 --> 00:15:36,360
망할 이게 뭐야

388
00:15:38,660 --> 00:15:40,040
이게 왜 여기 있죠?

389
00:15:40,720 --> 00:15:42,720
이런 기능은 여기 있으면 안돼요

390
00:15:42,720 --> 00:15:43,900
어쨌든

391
00:15:44,040 --> 00:15:47,300
이걸 발견한날 인터넷에서 저는 매우 슬피 울었어요

392
00:15:47,440 --> 00:15:49,580
왜냐하면, 저런 기능은 옳지 않기 때문이에요

393
00:15:49,980 --> 00:15:51,560
그래서 전 여기에 가서

394
00:15:52,660 --> 00:15:55,240
이 기능에 대해 불만을 표시하며 울어댔어요

395
00:15:55,400 --> 00:15:58,120
문제에 빠진 다른 모든 어른들이 하는것 처럼 말이죠

396
00:15:58,180 --> 00:16:00,300
독일에서 온 제 친구인 Yann 은

397
00:16:00,780 --> 00:16:03,200
희망의 메세지로 응답 했어요

398
00:16:03,200 --> 00:16:04,480
이게 바로 그 메세지에요

399
00:16:04,880 --> 00:16:10,960
[Josh Long에 의해 비활성화 됨]

400
00:16:12,080 --> 00:16:14,080
괜찮아 질거에요  걱정 말아요

401
00:16:14,380 --> 00:16:16,380
우린 인텔리제이를 다시 위대하게 만들 겁니다.

402
00:16:16,660 --> 00:16:18,660
[웃음]

403
00:16:18,660 --> 00:16:20,520
자 계속 합시다.

404
00:16:20,900 --> 00:16:22,900
자 이제 동작하는 애플리케이션이 있으므로

405
00:16:22,900 --> 00:16:24,320
커맨드라인에서 구동 할 수 있겠죠

406
00:16:24,480 --> 00:16:27,140
다운로드 디렉토리 안의,

407
00:16:29,320 --> 00:16:31,640
reservation-service

408
00:16:31,640 --> 00:16:33,900
아, 놓친 부분이 있는데 웹 요청으로 데이터를 볼 수도 있어요

409
00:16:33,980 --> 00:16:35,980
로컬호스트:8080/reservations

410
00:16:36,120 --> 00:16:38,140
REST API 를 통해 내 데이터를 볼 수 있죠

411
00:16:38,140 --> 00:16:39,840
하이퍼미디아라고 불리는 거에요 (Hypermedia)

412
00:16:39,900 --> 00:16:43,720
HATEOAS, Hypermedia as engine of application state

413
00:16:43,900 --> 00:16:46,360
이건 스스로를 설명하는 REST API 입니다.

414
00:16:47,020 --> 00:16:49,260
굉장히 강력한 API 죠

415
00:16:49,260 --> 00:16:50,920
그리고 이 기능은 Spring HATEOAS 를 사용 합니다.

416
00:16:51,100 --> 00:16:53,400
그래서 우린 이렇게 데이터를 볼 수 있는 거에요. 잊지 마세요

417
00:16:54,480 --> 00:16:56,480
지금은 별 문제 없이 애플리케이션을 실행 할 수 있지만

418
00:16:56,660 --> 00:16:58,800
만약 설정을 변경하고 싶으면 어쩌죠?

419
00:16:59,040 --> 00:17:02,060
그럼 애플리케이션으로 돌아가서 application properties 를 열고

420
00:17:02,360 --> 00:17:05,300
예를 들면 server.port 를 명시할 수 있겠죠

421
00:17:05,580 --> 00:17:08,260
그렇지만 서버 포트를 JAR 안에서 변경하고 싶진 않아요

422
00:17:08,260 --> 00:17:09,720
다시 컴파일 해야 하니까요

423
00:17:09,860 --> 00:17:12,160
그래서 이 설정을 JAR의 외부에서 지정할 거에요

424
00:17:12,220 --> 00:17:15,300
중앙화 된 설정 서버를 이용할거에요

425
00:17:15,660 --> 00:17:17,660
이 설정을 들고 있는 서버는

426
00:17:17,800 --> 00:17:20,800
안전하게 암호화된 상태로 정보를 제공할 수 있어요

427
00:17:20,960 --> 00:17:25,300
그리고 설정을 변경하는데 프로세스를 재시작 하지 않아도 되요

428
00:17:25,540 --> 00:17:30,480
이런 기능성은 다수의 인스턴스에서 구동 되는 애플리케이션에 필요한 설정을 한군데서 관리할 수 있고

429
00:17:30,820 --> 00:17:34,980
저널링이나 변경 사항을 추적할 수 있는 능력을 제공하는데

430
00:17:35,160 --> 00:17:39,600
누가 언제 설정을 어떻게 변경 했는지, 그리고 필요하다면 롤백도 가능합니다.

431
00:17:39,840 --> 00:17:44,500
이걸 위해서는 설정 파일보다 조금 더 세련된 방법을 사용할건데요

432
00:17:44,560 --> 00:17:46,880
다시 START.SPRING.IO 로 돌아가서

433
00:17:46,880 --> 00:17:48,840
제가 인터넷에서 두번째로 좋아하는 그곳이죠

434
00:17:49,280 --> 00:17:51,940
Config service 를 만들 겁니다.

435
00:17:52,960 --> 00:17:54,960
생성 버튼을 누르구요

436
00:17:56,280 --> 00:17:59,680
그리고 저는 파일 시스템을 이용할 건데요

437
00:17:59,680 --> 00:18:01,140
요기

438
00:18:01,140 --> 00:18:02,760
제 데스크탑에요

439
00:18:09,460 --> 00:18:11,460
그리고 여기에 git 레포지트리가 있습니다.

440
00:18:11,460 --> 00:18:13,420
제 애플리케이션들에 필요한 설정이 모두 담겨 있죠

441
00:18:13,420 --> 00:18:14,980
이 설정들을 가져 올거구요

442
00:18:15,020 --> 00:18:17,020
git clone

443
00:18:17,020 --> 00:18:18,500
데스크탑으로 복사하구요

444
00:18:18,500 --> 00:18:20,480
요 위치로 이동하고,

445
00:18:22,420 --> 00:18:25,560
그리고 새로 생성한 컨피그 서버에

446
00:18:25,600 --> 00:18:27,600
설정이 담겨진 디렉토리를 사용하라고 명시 합니다.

447
00:18:27,700 --> 00:18:29,700
그래서 여기에

448
00:18:29,780 --> 00:18:31,780
config.server.git

449
00:18:32,100 --> 00:18:34,100
.uri 의 위치는

450
00:18:34,100 --> 00:18:36,080
홈 디렉토리 하위의,

451
00:18:36,080 --> 00:18:37,280
데스크탑 하위의,

452
00:18:37,500 --> 00:18:40,800
config 그리고 컨피그 서버가 동작할 포트를 명시 합니다.

453
00:18:41,220 --> 00:18:43,220
그리고 컨피그 서버의 코드에서

454
00:18:43,500 --> 00:18:45,840
"아브라카다브라"하고 말해 줍니다.

455
00:18:46,020 --> 00:18:48,020
@EnableConfigServer

456
00:18:48,020 --> 00:18:49,180
짜잔~~

457
00:18:49,880 --> 00:18:53,280
그럼 이 컨피그 서버는 포트 8888을 사용해서 구동될 겁니다.

458
00:18:54,740 --> 00:18:56,740
제가 만든 마이크로 서비스는 [reservation-service]

459
00:18:56,800 --> 00:18:58,920
이 컨피그 서버에 접근할 수 있습니다.

460
00:18:59,220 --> 00:19:03,080
상상해 보세요. 나는 reservation-service 라는 이름의 마이크로 서비스 입니다.

461
00:19:03,980 --> 00:19:07,260
보이죠? 이게 이름 입니다.

462
00:19:07,700 --> 00:19:09,820
컨피그 서버에 접근 해서

463
00:19:09,940 --> 00:19:11,840
두개의 key-value 를 확인 할 수 있습니다.

464
00:19:11,940 --> 00:19:14,060
reservation-service.properties와

465
00:19:14,100 --> 00:19:15,420
application.properties 죠

466
00:19:15,660 --> 00:19:17,660
모든 마이크로 서비스들은

467
00:19:18,120 --> 00:19:20,540
application.properties 를 참조하게 됩니다.

468
00:19:20,780 --> 00:19:22,780
그리고 reservation-service 하나만

469
00:19:22,840 --> 00:19:25,220
reservation-service 라는 이름의 마이크로 서비스 하나만,

470
00:19:25,340 --> 00:19:27,600
이 설정을 참조 합니다. 서버 포트,

471
00:19:28,600 --> 00:19:29,880
서버 포트

472
00:19:31,180 --> 00:19:33,360
이게 아래의 이 서버 포트 설정을 오버라이드 합니다.

473
00:19:33,760 --> 00:19:35,760
자기 이름의 설정을 더 우선 참조 하는 거죠

474
00:19:35,760 --> 00:19:37,660
여기 보시면, 메세지가 있습니다.

475
00:19:38,160 --> 00:19:40,300
저는 이 메세지를 사용하고 싶은데요

476
00:19:40,580 --> 00:19:42,900
우리의 reservation-service 를 좀 바꿔 봅시다.

477
00:19:43,200 --> 00:19:45,980
아, 기억 하셔야 할건 우리 class path 는 여기 있습니다.

478
00:19:45,980 --> 00:19:47,760
class path 에 이게 있죠

479
00:19:48,220 --> 00:19:52,120
바로 spring-cloud-starter-config 의존성인데요

480
00:19:52,280 --> 00:19:54,280
이제 application.properties 로 가서

481
00:19:54,360 --> 00:19:57,240
spring.cloud.config.uri 는

482
00:19:57,520 --> 00:20:01,660
http://로컬호스트:8888 이며,

483
00:20:01,820 --> 00:20:04,320
그리고 애플리케이션에 이름을 주어서

484
00:20:04,460 --> 00:20:07,360
이게 내 이름이고, 이 이름으로 된 설정을 참조할거야 하는 정보를 줍니다.

485
00:20:07,620 --> 00:20:13,400
그리고 이 정보는 bootstrap.properties 를 통해 제공 될건데

486
00:20:13,500 --> 00:20:17,360
이건 스프링 부트 애플리케이션이 시작할때 참조하는 설정입니다.

487
00:20:17,360 --> 00:20:18,940
bootstrap.properties

488
00:20:19,180 --> 00:20:21,440
자, 이게 정상적으로 동작 한다면

489
00:20:21,560 --> 00:20:24,960
애플리케이션은 8080 포트가 아니라

490
00:20:25,180 --> 00:20:27,380
8000 으로 동작할 겁니다. [설정에 있었던]

491
00:20:27,380 --> 00:20:29,140
컨피그 서버를 보면,

492
00:20:29,140 --> 00:20:31,120
8000을 사용해라 하고 명시가 되어 있지요

493
00:20:31,900 --> 00:20:34,500
그리고 우린 이 메세지를 볼 수 있어야겠죠?

494
00:20:34,500 --> 00:20:35,740
동작하는지 봅시다

495
00:20:35,940 --> 00:20:38,140
reservation-service 애플리케이션으로 돌아가서

496
00:20:38,140 --> 00:20:39,480
이 아래에

497
00:20:39,700 --> 00:20:41,700
@RestController , clss

498
00:20:41,860 --> 00:20:44,220
MessageRestController

499
00:20:44,360 --> 00:20:46,360
@Value

500
00:20:47,000 --> 00:20:49,000
message

501
00:20:49,480 --> 00:20:52,360
private String msg, 그리고 엔드 포인트를

502
00:20:52,460 --> 00:20:54,640
/message

503
00:20:54,640 --> 00:20:56,580
String read()

504
00:20:56,840 --> 00:21:01,640
그리고 저는 이 메세지 설정을 프로세스 재시작 없이 바꾸고 싶으므로

505
00:21:01,720 --> 00:21:05,220
@RefreshScope 를 지정합니다.

506
00:21:06,400 --> 00:21:09,200
이제 애플리케이션을 재시작 하고, 동작 하는지 봅시다.

507
00:21:09,260 --> 00:21:11,260
동작하길 바라지만, 글쎄요 저도 몰라용

508
00:21:12,040 --> 00:21:12,860
알지도 몰라

509
00:21:12,860 --> 00:21:13,640
아몰랑

510
00:21:13,640 --> 00:21:14,380
아나?

511
00:21:14,520 --> 00:21:16,520
그치만 여러분은 모르죠? 그니까

512
00:21:16,520 --> 00:21:17,900
이건 미스테리 입니다.

513
00:21:17,900 --> 00:21:19,000
괜찮을 거에요

514
00:21:20,060 --> 00:21:22,060
어서, 더 빨리,

515
00:21:22,060 --> 00:21:23,680
자 여기 메세지가 나왔네요

516
00:21:23,680 --> 00:21:25,340
헤헤헤 동작 했어요

517
00:21:26,660 --> 00:21:28,660
커맨드 라인으로 가 봅시다

518
00:21:28,840 --> 00:21:32,440
이제 reservation-service.properties 가 있는 디렉토리로

519
00:21:32,540 --> 00:21:34,080
atom 을 사용해서 파일을 열어 봅니다.

520
00:21:34,500 --> 00:21:36,500
나왔네요

521
00:21:36,660 --> 00:21:40,860
여기 보시면 Hello World! 가 있는데, 다른거로 바꾸고 싶네요

522
00:21:40,940 --> 00:21:48,140
이렇게 [봉쥬르 하고 행사 이름 어쩌고 쓴다]

523
00:21:48,400 --> 00:21:53,580
레딧을 위해서 이렇게 이렇게 이렇게

524
00:21:54,280 --> 00:21:56,780
제가 얼마나 반가운지 아시겠죠

525
00:21:57,200 --> 00:22:00,320
자 이제 파일을 변경 했으니 commit 을 하고,

526
00:22:02,600 --> 00:22:05,760
메세지를 YOLO라고 씁니다.

527
00:22:05,860 --> 00:22:08,980
자, 이제 보시면 변경된 메세지를 컨피그 서버에서는 확인할 수 있습니다.

528
00:22:08,980 --> 00:22:10,020
요 있죠?

529
00:22:10,340 --> 00:22:12,920
하지만 실제 서비스에는 아직 설정이 반영되지 않았습니다.

530
00:22:13,060 --> 00:22:16,380
그래서 이 설정을 다시 불러오도록 커맨드를 사용 할 수 있는데

531
00:22:16,440 --> 00:22:18,440
비어있는 HTTP POST 를

532
00:22:18,620 --> 00:22:24,560
로컬호스트:8000/refresh 에 빈 POST 를 curl 로 전달 합니다.

533
00:22:24,660 --> 00:22:27,660
시작하기 전에, 두 화변을 동시에 봅시다. 준비 됬나요?

534
00:22:29,200 --> 00:22:30,220
자, 바뀌었죠?

535
00:22:30,900 --> 00:22:32,900
자, 이게 컨피그 서버와 클라이언트가 동작 하는 방법입니다.

536
00:22:32,900 --> 00:22:33,920
괜찮죠?

537
00:22:34,060 --> 00:22:36,700
여기에는 엄청 더 많은 주제가 있지만, 시간이 별로 없네요.

538
00:22:36,860 --> 00:22:40,740
자, 이젠 서비스 디스커버리와 등록에 대해 알아 봅시다.

539
00:22:41,040 --> 00:22:43,680
엄청나게 동적인 클라우드 기반의 시스템에서는

540
00:22:43,680 --> 00:22:45,040
그리고 무지 많은 마이크로 서비스가 구동중일때는

541
00:22:45,160 --> 00:22:48,180
다른 서비스와 연결되어 서로 정보를 주고 받는것이 매우 중요한데,

542
00:22:48,300 --> 00:22:51,620
이건 다른 서비스가 네트워크의 어디에서 동작하는지 몰라도 가능해야 합니다.

543
00:22:51,620 --> 00:22:53,160
DNS를 사용하실 수도 있겠지만,

544
00:22:53,160 --> 00:22:57,700
DNS는 클라우드 기반에서는 몇가지 이유로 인해 매우 나쁜 선택인데,

545
00:22:57,900 --> 00:22:59,900
첫째로, DNS는 캐싱 되어야 하기 때문이죠

546
00:23:00,420 --> 00:23:04,420
리소스들이 생겨나고 죽고, 다시 살아나는 동적인 환경에서는

547
00:23:04,500 --> 00:23:06,780
캐싱은 적절한 방법이 아닙니다.

548
00:23:06,880 --> 00:23:08,880
두번째로, DNS는 멍청한 프로토콜이에요

549
00:23:09,100 --> 00:23:11,680
특정 서비스 접근을 위해 요청을 수행 했는데,

550
00:23:11,680 --> 00:23:13,460
그쪽에 아무 서비스도 동작하고 있지 않다면

551
00:23:13,600 --> 00:23:15,880
예를 들어 myservice.com 에 요청을 했는데

552
00:23:15,880 --> 00:23:17,340
거기 아무것도 없다면

553
00:23:17,480 --> 00:23:20,620
10개의 인스턴스가 로드밸런서에서 동작중인데, 다 죽었다면

554
00:23:20,680 --> 00:23:22,680
제 클라이언트는 블럭 당할 겁니다.

555
00:23:22,840 --> 00:23:26,220
요청에 대해 돌아올 수 없는 응답을 기다리는 상태로, 행이 되겠죠

556
00:23:26,440 --> 00:23:30,380
만약 마이클 T. 나이가드 (Michael T. Nygard)의

557
00:23:30,860 --> 00:23:33,820
Release It! 을 읽었다면,

558
00:23:33,840 --> 00:23:36,700
아마도 적절한 타임 아웃을 설정 했을 겁니다.

559
00:23:36,700 --> 00:23:37,840
하지만 대부분 그렇지 않죠

560
00:23:37,840 --> 00:23:38,760
그래서 블럭된 상태가 됩니다.

561
00:23:38,900 --> 00:23:42,780
상대방 서비스가 살아 있는지 아닌지를 확인할 수 있어야 합니다.

562
00:23:43,120 --> 00:23:45,760
또 저는 커스텀 로드 밸런싱을 처리하고도 싶어요

563
00:23:45,800 --> 00:23:49,120
일반적으로 여러분이 사용하는 로드밸런서는 매우 멍청합니다.

564
00:23:49,400 --> 00:23:52,480
스프링 이니셜라이저에도 체크박스가 있는데, 그다지 좋은건 아니죠

565
00:23:52,480 --> 00:23:54,200
나쁜 체크 박스 입니다.

566
00:23:54,200 --> 00:23:55,660
왜 멍청한 체크 박스냐면,

567
00:23:55,660 --> 00:23:57,020
라운드 로빈을 해라! [요청별로 서버를 돌아가면서 사용]

568
00:23:57,100 --> 00:23:59,960
근데 만약 데이터센터의 가용 여부에 따른 로드 밸런싱을 원한다면

569
00:23:59,960 --> 00:24:01,680
멀티 테넌트 (다중 사용자)환경간 밸런싱을 지원 해야 한다면

570
00:24:01,840 --> 00:24:05,740
상태 정보 저장을 위한 로컬 캐시 라우팅을 사용하고자 한다면

571
00:24:05,800 --> 00:24:09,440
예를 들어 OAuth 토큰을 가지고 넷플릭스에 연결해서

572
00:24:09,440 --> 00:24:10,860
스트리밍 비디오를 요청해야 한다면

573
00:24:11,000 --> 00:24:15,700
서버 고정을 위해 Sticky 세션을 원하지만 JSession 쿠키가 아니라면

574
00:24:15,700 --> 00:24:17,540
이러한 다양한 요구를 수용하기 위해

575
00:24:17,700 --> 00:24:22,700
서비스 id가 있고, 호스트 정보와 포트 정보를 담은 테이블을 가진, DNS 비스무리한게 필요한데,

576
00:24:22,700 --> 00:24:24,700
이것과는 다른게 필요합니다.

577
00:24:24,700 --> 00:24:26,120
"서비스 레지시트리" 를 사용할거에요

578
00:24:26,180 --> 00:24:28,900
서비스 레지스트리는 클라우드를 위한 전화번호부인데

579
00:24:29,020 --> 00:24:31,460
이미 많은 종류의 서비스 레지스트리가 존재 합니다.

580
00:24:31,520 --> 00:24:37,100
하지만 여기서는 확장성과 그 동작이 검증된 넷플릭스의 "유레카"를 사용합니다.

581
00:24:37,320 --> 00:24:39,320
유레카 서버를 사용하구요

582
00:24:39,320 --> 00:24:41,180
컨피그 클라이언트도 추가 합니다.

583
00:24:41,320 --> 00:24:43,320
이것 외에도 여러분은

584
00:24:43,320 --> 00:24:44,500
아파치의 주키퍼나

585
00:24:44,500 --> 00:24:46,200
Hashcorp의 Consul,

586
00:24:46,200 --> 00:24:48,020
이것들 역시 좋은 선택이며,

587
00:24:48,100 --> 00:24:50,260
스프링 클라우드에서 동일하게 사용할 수 있습니다.

588
00:24:50,540 --> 00:24:53,640
세가지 모두에 동일한 클라이언트를 사용할 수 있는데,

589
00:24:53,740 --> 00:24:56,220
뭐 상관 없겠죠. 어쨌든 굉장히 사용하기 쉽습니다.

590
00:24:56,340 --> 00:25:00,640
심지어 스프링 클라우드가 설치된 인스턴스를 사용할 수도 있습니다.

591
00:25:00,640 --> 00:25:01,800
코드로 가서,

592
00:25:03,800 --> 00:25:06,820
@EnableEurekaService, 아브라카다브라~

593
00:25:07,060 --> 00:25:16,780
[참조할 컨피그 서버의 위치를 설정]

594
00:25:16,960 --> 00:25:20,740
애플리케이션 이름은, eureka-service

595
00:25:20,980 --> 00:25:24,500
그리고 이 파일 이름을 bootstrap.properties 로 변경 합니다.

596
00:25:25,020 --> 00:25:27,280
자, 이제 실행해 봅시다.

597
00:25:27,280 --> 00:25:28,540
휴~

598
00:25:29,840 --> 00:25:33,480
이 서비스는 8761 포트를 사용할 거구요

599
00:25:33,580 --> 00:25:35,940
이제 아까 만든 reservation-service가 유레카 서버에게

600
00:25:36,000 --> 00:25:38,000
"여기요~, 저 여기서 동작해요~"

601
00:25:38,000 --> 00:25:39,700
누구나 내 서비스가 필요하면,

602
00:25:39,800 --> 00:25:41,880
여기 알려드린 내 호스트, 포트 정보로 오세요

603
00:25:41,880 --> 00:25:43,680
자 이제 reservation-service 로 돌아가서

604
00:25:45,720 --> 00:25:49,240
좀 많은 코드를 추가할건데요, 여기

605
00:25:49,400 --> 00:25:51,620
@EnableDiscoveryClient, 그리고 재시작 합니다. 
[한줄만 추가하면 됨]

606
00:25:54,920 --> 00:25:58,640
그리고 이제 레지스트리 서비스를 살펴 보면,
[ http://localhost:8761/ ]

607
00:25:59,440 --> 00:26:01,440
첫번째로는

608
00:26:01,700 --> 00:26:04,280
아주 훌륭한 퀄리티의 gif 애니메이션에 주목 하시구요,

609
00:26:04,280 --> 00:26:05,320
엄청나죠?

610
00:26:06,380 --> 00:26:11,200
이제 아래를 보면, 아직 아무 서비스가 없죠?

611
00:26:11,400 --> 00:26:14,480
그치만 우린 reservation-service 를 클라이언트로 등록 했잖아요

612
00:26:14,600 --> 00:26:18,820
자 이제 리프레시를 해보면 서비스가 등록된 것을 확인할 수 있죠

613
00:26:19,420 --> 00:26:23,700
여기 보시면 이 서비스가 어디서 동작하는지 포트랑 나오구요

614
00:26:23,780 --> 00:26:26,220
자, 이제 이 서비스와 연동하는 클라이언트를 만들어 봅시다.

615
00:26:26,360 --> 00:26:28,760
START.SPRING.IO 로 다시 돌아가구요

616
00:26:28,820 --> 00:26:30,960
아주 특별한 유형의 클라이언트를 만들어 봅니다.

617
00:26:30,960 --> 00:26:32,680
엣지 서비스 인데요 (edge-service)

618
00:26:32,680 --> 00:26:34,160
컨피그 서버를 추가하구요 
[하지만 손은 클라이언트를 추가 ]

619
00:26:34,160 --> 00:26:35,300
유레카도 추가하고

620
00:26:35,320 --> 00:26:37,540
동일한 클라이언트 앱스트랙션인 디스커버리죠

621
00:26:37,540 --> 00:26:38,640
Hystrix 도 추가하고

622
00:26:38,640 --> 00:26:40,260
이건 서킷 브레이커구요,

623
00:26:40,260 --> 00:26:42,680
컨피그 클라이언트 추가하고 웁스

624
00:26:42,680 --> 00:26:44,140
RabbitMQ,

625
00:26:44,220 --> 00:26:46,340
스트림 프로세싱, Zipkin 클라이언트

626
00:26:47,240 --> 00:26:49,240
마이크로 프락시인 Zuul 도 추가 합니다.

627
00:26:49,600 --> 00:26:51,600
음...

628
00:26:51,920 --> 00:26:53,920
Web,

629
00:26:53,920 --> 00:26:55,400
Hypermedia

630
00:26:55,400 --> 00:26:56,320
이정도면 된 것 같네요

631
00:26:56,380 --> 00:26:59,000
이건 일반적인 종류의 클라이언트인데요,

632
00:26:59,000 --> 00:27:02,000
서비스 레지스트리에 등록된 서비스를 발견 하고,

633
00:27:02,020 --> 00:27:04,360
2가지 종류의 엣지 서비스를 빌드할 건데요

634
00:27:04,640 --> 00:27:11,260
엣지 서비스는 전체 아키텍처의 바깥에서 동작하는 컴포넌트 구요,

635
00:27:11,360 --> 00:27:21,340
이건 아이폰, 안드로이드, HTML5, 또는 테슬라, 플레이스테이션, 로쿠(?), 냉장고 등에서 오는 요청을 받는 역할을 합니다.

636
00:27:21,480 --> 00:27:24,660
IoT에는 굉장히 많은 타입의 클라이언트가 있죠

637
00:27:24,760 --> 00:27:27,480
각각은 서로 다른 보안 수준,

638
00:27:27,500 --> 00:27:30,700
페이로드, 프로토콜이 서로 다른 문제가 있을 수 있습니다.

639
00:27:30,880 --> 00:27:34,420
정말 굉장히 다양한 걱정거리가 생길 수 있는데,

640
00:27:34,480 --> 00:27:36,920
어쨌든 이를 수용하기 위해서 모든 마이크로서비스를 바꿀 순 없죠

641
00:27:37,060 --> 00:27:39,740
대신, 여러분은 아이폰 전용의 엣지 서비스를 만들 수 있습니다.

642
00:27:39,840 --> 00:27:41,920
HTML5 엣지 서비스,

643
00:27:41,920 --> 00:27:43,060
안드로이드 엣지 서비스,

644
00:27:43,140 --> 00:27:46,400
이런 엣지 서비스들은 일종의 "도어맨" 역할을 합니다.

645
00:27:46,580 --> 00:27:50,300
이 엣지는 여러분의 시스템과 바깥 세상 사이의 창구 역할을 하죠

646
00:27:50,440 --> 00:27:52,440
자, 이제 해 봅시다.

647
00:27:52,580 --> 00:27:54,580
application.properties

648
00:27:54,640 --> 00:27:58,240
스프링 애플리케이션 이름을 reservation-client 로,

649
00:27:58,380 --> 00:28:06,180
컨피그 서버의 설정을 추가하고,

650
00:28:06,440 --> 00:28:09,280
bootstrap.properties 로 파일 이름을 변경하고

651
00:28:09,500 --> 00:28:11,960
자, 이제 첫번째 종류의 엣지 서비스가 생겼습니다.

652
00:28:12,080 --> 00:28:14,200
이건 멍청한 마이크로 프락시구요

653
00:28:14,360 --> 00:28:17,580
이 마이크로 프락시는 외부의 요청을 받아서,

654
00:28:17,760 --> 00:28:20,120
내부의 백엔드 서비스로 바로 포워딩 합니다.

655
00:28:20,120 --> 00:28:21,980
여기에 Zuul 을 사용할 거구요

656
00:28:22,140 --> 00:28:29,660
만약 여러분이 그리스 신화나  "고스트 버스터즈" 영화를 기억한다면

657
00:28:29,780 --> 00:28:36,000
지금 보시는게 고스트버스터즈 영화의 Zuul 이죠

658
00:28:36,000 --> 00:28:37,420
어어어~

659
00:28:44,640 --> 00:28:46,640
어쩄건,

660
00:28:48,640 --> 00:28:52,840
Zuul 은 프락시인데, 외부로 부터 요청을 받죠

661
00:28:53,840 --> 00:28:56,320
그런데 제 친구가 말하길,

662
00:28:56,320 --> 00:28:57,940
"우린 저거 모르잖아"

663
00:28:57,940 --> 00:28:59,300
몰라

664
00:29:00,360 --> 00:29:03,840
글쎄, 되게 좋은데서 온 사람 아닐까?

665
00:29:03,840 --> 00:29:05,780
하와이에서 왔을 수도 있지

666
00:29:05,780 --> 00:29:07,100
모르지만

667
00:29:07,260 --> 00:29:09,480
어쨌든 그렇죠

668
00:29:10,380 --> 00:29:14,340
저는 9999 포트에서 동작하는 엣지 서비스가 있습니다.

669
00:29:14,340 --> 00:29:16,040
제 엣지 서비스구요

670
00:29:17,440 --> 00:29:19,440
스프링 클라우드는 "라우트" 를 설정 합니다.

671
00:29:19,680 --> 00:29:23,600
외부로 부터, 내부 백엔드의 마이크로 서비스로 가는 라우트죠

672
00:29:23,800 --> 00:29:27,460
자, 이렇게 요청을 하면,

673
00:29:27,460 --> 00:29:28,520
보이나요?

674
00:29:28,520 --> 00:29:29,580
엣지 서비스,

675
00:29:29,580 --> 00:29:30,960
서비스 id,

676
00:29:30,960 --> 00:29:32,140
경로.

677
00:29:32,140 --> 00:29:34,000
여기에 실제로 동작하는 서비스가 있구요,

678
00:29:34,000 --> 00:29:35,700
로컬 호스트,

679
00:29:35,820 --> 00:29:38,040
8000/reservations

680
00:29:38,360 --> 00:29:42,940
지금 보시는게 reservation-service 구요,

681
00:29:44,840 --> 00:29:46,840
지금 보시는 이게 엣지 서비스 입니다.

682
00:29:47,680 --> 00:29:50,780
9999/reservation-service/reservaions 죠

683
00:29:51,140 --> 00:29:53,700
아주 편리하게 동작하는 프락시죠

684
00:29:53,700 --> 00:29:55,540
만약 제가 HTML5 가 있다면,

685
00:29:55,540 --> 00:29:57,480
SSL을 추가하고

686
00:29:57,480 --> 00:30:00,620
HTTP 기반의 OAuth 를 구현하면, 아마 작업은 끝날겁니다.

687
00:30:00,620 --> 00:30:02,120
어쩔때는,

688
00:30:02,120 --> 00:30:04,720
백엔드로 부터 응답된 데이터를 변경해야 할 수도 있습니다.

689
00:30:04,840 --> 00:30:08,700
또는 요청을 변경해서 백엔드에 요청하고, 응답을 바꿀수도 있죠

690
00:30:08,920 --> 00:30:10,920
이런건 다른 종류의 엣지 서비스 입니다.

691
00:30:10,920 --> 00:30:12,820
바로 API  게이트웨이라고 불리는 것이죠

692
00:30:12,820 --> 00:30:14,700
이건 마이크로 프락시인데,

693
00:30:14,900 --> 00:30:17,540
다른 종류의 엣지 서비스는 API 게이트웨이라고 합니다.

694
00:30:17,620 --> 00:30:20,260
간단하고, 멍청하긴 하지만 하나 만들어 보도록 합시다.

695
00:30:20,260 --> 00:30:21,960
이거 흥미로운 주제거든요.

696
00:30:22,540 --> 00:30:25,340
자, 여기 이 부분으로 가서 @RestController 를 추가하고

697
00:30:25,460 --> 00:30:32,460
class ReservationApiGatewayRestController

698
00:30:32,800 --> 00:30:34,960
하! 짧죠?

699
00:30:35,700 --> 00:30:37,700
RequestMapping 에서는,

700
00:30:37,920 --> 00:30:40,420
누군가 이 엔드포인트로 요청하면,

701
00:30:41,240 --> 00:30:43,240
누군가 요청을

702
00:30:43,240 --> 00:30:45,100
이 엔드 포인트로 한다면

703
00:30:46,540 --> 00:30:52,120
9999/reservations/names 로 요청이 온다면

704
00:30:52,320 --> 00:30:54,580
이 요청을 우리는

705
00:30:54,920 --> 00:30:58,080
Reservation 오브젝트가 아니라

706
00:30:58,160 --> 00:31:01,040
이 전체가 아니라, 오로지 이름만 응답하는,

707
00:31:01,040 --> 00:31:02,880
단지 이름들만 응답할 겁니다.

708
00:31:03,120 --> 00:31:05,840
자, 아주 간단한 API 게이트웨이가 만들어 졌죠

709
00:31:05,840 --> 00:31:07,740
이제 HTTP 요청을 만들건데

710
00:31:07,820 --> 00:31:10,860
전 이제 좀 슬픈 무언가를 할거에요

711
00:31:10,860 --> 00:31:12,680
보시죠

712
00:31:12,800 --> 00:31:15,840
[스프링 부트 버전을 RC로 바꿈] 
2017년엔 필요 없음

713
00:31:16,960 --> 00:31:21,340
스프링 REST 템플릿을 사용할 거구요

714
00:31:21,340 --> 00:31:22,940
private final,

715
00:31:22,940 --> 00:31:24,220
RestTemplate

716
00:31:25,820 --> 00:31:28,860
컨스트럭터 생성하고, @Autowired 어노테이션 주고,

717
00:31:28,860 --> 00:31:30,540
그리고 여기서

718
00:31:30,620 --> 00:31:33,940
이 RestTemplate 이 좀 똑똑하게 만들어야 하는데,

719
00:31:33,940 --> 00:31:35,680
바로 로드 밸런싱이 가능하게 만들거에요

720
00:31:35,840 --> 00:31:37,840
질문이 생기는데요,

721
00:31:38,260 --> 00:31:40,260
어떤 인스턴스가 응답하는지 어떻게 알죠?

722
00:31:41,340 --> 00:31:45,280
지금은 1개 인스턴스 밖에 없지만, 10개를 가지고 있다면요?

723
00:31:46,560 --> 00:31:50,380
이런 동작은 넷플릭스의 리본(Ribbon)이라는 도구로 통제할 수 있습니다.

724
00:31:50,620 --> 00:31:52,620
리본은 클라이언트 사이드 로드밸런서 구요

725
00:31:52,980 --> 00:31:56,500
기본적으로 비교 기반으로 으로 동작합니다.

726
00:31:56,520 --> 00:31:59,740
인스턴스를 하나 선택하면, 요청을 그 인스턴스로 포워딩 합니다.

727
00:32:00,080 --> 00:32:02,080
이건 클라이언트에서 이루어지는 거에요, 서버가 아니라.

728
00:32:02,660 --> 00:32:04,660
사실 이건 이미 동작하고 있어요

729
00:32:04,660 --> 00:32:06,220
여기로 요청하게 되면,

730
00:32:06,220 --> 00:32:07,360
이 요청은 리본으로 가고,

731
00:32:07,360 --> 00:32:08,220
리본은 다시 유레카랑 통신하고

732
00:32:08,340 --> 00:32:10,640
유레카는 호스트와 포트 정보를 응답하고,

733
00:32:10,640 --> 00:32:12,040
요청은 적절한 백엔드로 전달 됩니다.

734
00:32:12,200 --> 00:32:15,420
이런 동작을 REST 클라이언트에서도 구현하려고 하는데요

735
00:32:15,580 --> 00:32:19,800
여기선 LoadBalanced RestTemplate 를 만들겁니다.

736
00:32:20,000 --> 00:32:26,940
[코딩 중]

737
00:32:28,940 --> 00:32:30,940
자 준비 됬구요

738
00:32:31,040 --> 00:32:33,720
아주 간단한 콜을 만들어 봅시다.

739
00:32:33,940 --> 00:32:39,600
[코딩중]

740
00:32:39,640 --> 00:32:42,880
여기 보시면 서비스 id가 사용되죠. DNS 아니구요,

741
00:32:42,940 --> 00:32:44,940
[코딩중]

742
00:32:44,980 --> 00:32:46,980
HTTP GET

743
00:32:46,980 --> 00:32:48,240
nobody

744
00:32:48,480 --> 00:32:50,820
제가 응답 받기를 원하는 데이터는,

745
00:32:51,120 --> 00:32:57,120
Hypermedia API 로 가져온 리소스의 컬렉션 이구요

746
00:32:57,400 --> 00:32:59,400
페이로드 타입은 Reservation 입니다.

747
00:33:01,060 --> 00:33:03,060
class Reservation

748
00:33:03,360 --> 00:33:11,120
[코딩중]

749
00:33:11,820 --> 00:33:15,400
나는 body 만 필요하고, 나머진 필요 없고

750
00:33:15,400 --> 00:33:17,100
Content,

751
00:33:17,140 --> 00:33:18,020
stream,

752
00:33:18,020 --> 00:33:18,840
map

753
00:33:21,220 --> 00:33:23,600
Reservation 에서 ReservationName 으로

754
00:33:23,600 --> 00:33:25,420
자 동작하는지 봅시다

755
00:33:25,420 --> 00:33:27,340
시작하는 도안 물좀 마시구요

756
00:33:33,640 --> 00:33:35,640
여기 정말 덥네요

757
00:33:38,940 --> 00:33:40,940
좋습니다, 동작하는지 봅시다.

758
00:33:41,360 --> 00:33:43,360
헐?

759
00:33:44,620 --> 00:33:46,620
아 동작 하네요

760
00:33:46,640 --> 00:33:48,640
자, 아주 간단한 엣지 서비스 입니다.

761
00:33:48,780 --> 00:33:50,780
다른 서비스에 요청하는 클라이언트를 만들었어요

762
00:33:50,780 --> 00:33:52,140
그리고 응답에 변형을 가했죠

763
00:33:52,140 --> 00:33:53,780
하지만,

764
00:33:53,980 --> 00:33:57,180
뒤에 하나 이상의 인스턴스가 있을때는 모든게 괜찮겠지만요

765
00:33:57,220 --> 00:34:01,260
예를 들면, 1개, 10개가 있을때는 문제 없겠지만

766
00:34:01,260 --> 00:34:02,520
하지만 0개라면 어떨까요

767
00:34:03,280 --> 00:34:05,280
뻥! 그쵸?

768
00:34:05,680 --> 00:34:08,060
만약 접근 가능한 백엔드 서비스가 하나도 없다면 익셉션이 날거고

769
00:34:08,180 --> 00:34:11,880
제 아이폰 사용자는 엄청난 길이의 스택 트레이스를 보겠죠

770
00:34:12,040 --> 00:34:14,040
그쵸? 그건 나쁜거에요

771
00:34:14,140 --> 00:34:16,900
그래서 우린 장애 대응과 복구에 대해 생각해야 합니다.

772
00:34:16,980 --> 00:34:21,540
우리는 "서킷 브레이커"를 사용할 건데요. 혹시 들어보셨나요?

773
00:34:25,240 --> 00:34:28,540
[프랑스어]

774
00:34:31,080 --> 00:34:33,080
이건 장애를 방지할거에요

775
00:34:33,180 --> 00:34:35,180
만약 너무 많은 전기가 흘러 들어오면,

776
00:34:35,640 --> 00:34:38,300
스위치가 열리면서 전기가 통하지 않는 상태가 되죠?

777
00:34:38,320 --> 00:34:40,580
불빛을 잃는 별로 달갑지 않은 상황이겠지만

778
00:34:41,600 --> 00:34:43,600
빛은 잃어도

779
00:34:43,740 --> 00:34:46,300
화재는 나지 않는 상황이 되겠죠

780
00:34:46,600 --> 00:34:49,600
빌딩을 잃는 것보다는 빛을 잠깐 잃는게 낫잖아요?

781
00:34:49,780 --> 00:34:51,960
그래서 Hystrix 라고 불리는 서킷 브레이커를 사용할겁니다.

782
00:34:52,160 --> 00:34:54,160
넷플릭스가 만든 도구구요

783
00:34:57,500 --> 00:35:00,260
누군가 아무나 이 메서드를 호출하면,

784
00:35:00,580 --> 00:35:04,920
뭔가 문제가 발생했거나 익셉션이 발생했다면

785
00:35:05,020 --> 00:35:07,620
이때 응답하는 fallback 메세지를 생성 합니다.

786
00:35:07,820 --> 00:35:09,820
지금 보시는게 fallback 메서드구요

787
00:35:09,980 --> 00:35:12,380
이 구현은 굉장히 간단한데요

788
00:35:12,380 --> 00:35:13,700
무언가가 잘못되면

789
00:35:13,700 --> 00:35:15,460
여기에 지정된 fallback 메서드를 호출합니다.

790
00:35:15,560 --> 00:35:18,140
넷플릭스는 이런식의 동작을 하는걸로 유명한데요

791
00:35:18,240 --> 00:35:20,980
예를 들어 검색 엔진이 없는데 요청이 되었다면,

792
00:35:20,980 --> 00:35:22,880
검색 엔진이 잠깐 휴가 갔다면

793
00:35:22,880 --> 00:35:26,840
여기 우리가 머신 러닝을 통해 얻은 추천 결과가 있다, 하고 응답 할 수 있습니다.

794
00:35:26,920 --> 00:35:30,180
이런 동작은 아무것도 없는 것 보다는 훨씬 나은 방법 입니다.

795
00:35:30,180 --> 00:35:31,520
이게 중요한거구요

796
00:35:31,620 --> 00:35:35,120
그리고 분산 시스템에서는, 모든게 언제든 죽을 수 있다고 가정합니다

797
00:35:35,260 --> 00:35:41,040
장애는 세금이나 죽음처럼, 항상 일어나는 일입니다.

798
00:35:41,200 --> 00:35:45,520
그래서 여러분은 이런 방식으로 서비스를 만들어야 합니다.

799
00:35:45,720 --> 00:35:48,560
읽기는 그렇다 치고, 그럼 쓰기는 어떻게 해야 할까요

800
00:35:48,600 --> 00:35:53,060
예를 들어 엣지 서비스로 보낸 내용을 백엔드 서비스가 받아서 데이터베이스에 넣는 구조라면?

801
00:35:53,060 --> 00:35:54,300
어떻게 해야 하죠?

802
00:35:54,300 --> 00:35:56,040
쓰기에 대해 서킷 브레이커 적용은 어떻게 해야 할까요

803
00:35:56,040 --> 00:35:56,980
할 수 없죠. 그쵸?

804
00:35:57,240 --> 00:35:59,320
들어오는 데이터를 받아서

805
00:35:59,400 --> 00:36:02,060
백엔드가 동작 하지 않을때 그냥 요청을 드랍 하는게 아니라면

806
00:36:02,120 --> 00:36:05,100
백엔드 서비스가 동작하지 않더라도 문제가 발생하지 않도록 뭔가 해야 합니다.

807
00:36:05,260 --> 00:36:08,180
그리서 저는 "이벤츄얼 컨시스턴시" 를 사용할건데요

808
00:36:08,180 --> 00:36:09,880
여기에 메세징을 사용할 겁니다.

809
00:36:09,900 --> 00:36:11,900
스프링 클라우드 스트림 이라는 것도 사용할거구요

810
00:36:12,080 --> 00:36:15,520
이 도구의 역할은 서로 다른 서비스들이 메세징도구와 연동할 수 있는 일종의 브로커 입니다.

811
00:36:16,280 --> 00:36:19,060
여기서 새로운 엔드 포인트를 등록 할게요

812
00:36:20,040 --> 00:36:35,500
[코딩중]

813
00:36:36,180 --> 00:36:39,700
아 value 는 필요 없겠네요

814
00:36:39,880 --> 00:36:44,480
localhost:9999/reservation-service/ 이건 POST 입니다.

815
00:36:44,480 --> 00:36:45,960
자 이제 뭘 할까요?

816
00:36:46,100 --> 00:36:50,680
이제 이 메세지를 스프링 프레임워크의 메세지 채널에 넣을겁니다

817
00:36:50,820 --> 00:36:52,960
기본적으로는 Java util queue 죠

818
00:36:52,960 --> 00:36:54,600
그쵸? push, pop

819
00:36:54,600 --> 00:36:55,880
자, 해봅시다.

820
00:36:56,060 --> 00:36:58,320
이제 큐를 생성할 건데요,

821
00:36:58,520 --> 00:37:01,200
컨벤션에 의해 브로커에 자동으로 연결 됩니다

822
00:37:01,240 --> 00:37:03,380
그리고 여기에 이건,

823
00:37:03,500 --> 00:37:06,960
output 이라고 불리는 메세지 채널이라고 써 줍니다.

824
00:37:08,200 --> 00:37:10,520
나만의 인터페이스를 이렇게 구현할 수 있구요

825
00:37:10,520 --> 00:37:11,600
원하신다면 말이죠

826
00:37:12,600 --> 00:37:15,240
Crm 이라고 하고

827
00:37:15,560 --> 00:37:18,000
하나는 커스터머

828
00:37:18,560 --> 00:37:21,340
다른 하나는 주문용, 또 다른건 프로덕트용으로,

829
00:37:21,340 --> 00:37:22,060
등등

830
00:37:22,060 --> 00:37:23,460
이렇게도 할 수 있지만 여기에선

831
00:37:23,600 --> 00:37:26,240
실제로 하나의 서비스 밖에 없기 때문에 이럴 필요는 없죠

832
00:37:26,320 --> 00:37:29,300
이미 제공된 Source 를 사용할 겁니다.

833
00:37:29,940 --> 00:37:31,940
여기에 필요한 설정은 조금 나중에 살펴보기로 하구요

834
00:37:32,000 --> 00:37:34,360
일단 우리가 기억해야 할건, 우린 지금 채널을 만들었고

835
00:37:34,360 --> 00:37:35,260
그 채널 이름은 output 입니다.

836
00:37:35,260 --> 00:37:37,240
이게 어디에 연결되는지 누가 알겠어요

837
00:37:37,240 --> 00:37:39,200
이런건 코드 밖에 있어야 하는 정보입니다.

838
00:37:39,380 --> 00:37:43,040
이런건 설정을 통해 런타임에서 처리하도록 합시다.

839
00:37:44,500 --> 00:37:46,500
여기서 이제 주입을 할건데,

840
00:37:46,500 --> 00:37:48,400
코드에서 여기 부분이요

841
00:37:48,400 --> 00:37:49,820
@Autowired

842
00:37:50,220 --> 00:37:52,220
private Source

843
00:37:52,460 --> 00:38:00,980
[코딩중]

844
00:38:01,180 --> 00:38:03,180
이건 메세지 채널을 알려주죠

845
00:38:04,500 --> 00:38:09,840
[코딩중]

846
00:38:11,020 --> 00:38:13,980
채널에 메세지를 보낼건데, 이건 예약 이름을 페이로드로

847
00:38:14,100 --> 00:38:16,840
클라이언트로 부터 받은 데이터죠

848
00:38:16,840 --> 00:38:19,440
새로운 예약 이름을 가진 JSON 입니다.

849
00:38:19,620 --> 00:38:25,160
저는 이 메세지를 받아서, RabbitMQ 에 다운스트림으로 전달합니다.

850
00:38:25,580 --> 00:38:28,780
저의 pom.xml 에는 spring cloud stream 이라는게 들어있구요

851
00:38:30,540 --> 00:38:32,540
stream RabbitMQ

852
00:38:32,540 --> 00:38:34,360
이거 말고도 Kafka를 사용할 수도 있습니다

853
00:38:34,360 --> 00:38:36,260
Redis 나 다른 어떤것이든 가능하죠

854
00:38:36,260 --> 00:38:37,660
여기 필요한 의존성을 명시해 주면 됩니다

855
00:38:38,440 --> 00:38:42,740
기본적으로 이건 브로드 캐스팅으로 동작해요.

856
00:38:43,060 --> 00:38:45,060
지금 그런 방식을 원하는 건 아니죠. 우린 1:1 이 필요해요

857
00:38:45,360 --> 00:38:48,300
자, 이제 동일한 동작을 다른 곳에서 해 봅시다. 여기요

858
00:38:48,560 --> 00:38:51,300
[코딩중]

859
00:38:51,480 --> 00:38:54,480
Sink 는 메세지를 받는 부분입니다

860
00:38:54,540 --> 00:38:57,800
input 이고, output 처럼 여러분만의 인터페이스를 만들수도 있지만

861
00:38:57,960 --> 00:39:17,460
[코딩중]

862
00:39:17,680 --> 00:39:22,120
여기서 레포지트리 인젝트를 수행할 건데요

863
00:39:22,120 --> 00:39:23,780
큐로 부터 받은 데이터를 데이터베이스에 쓰는거죠

864
00:39:23,780 --> 00:39:25,560
요렇게요

865
00:39:26,840 --> 00:39:30,240
지금 보신게 바로 서비스쪽에서

866
00:39:33,580 --> 00:39:40,220
자 이제 애플리케이션을 시작하고, 그동안 물 한모금 하구요

867
00:39:42,840 --> 00:39:46,940
메세지가 들어오면 이 메서드가 호출되구요

868
00:39:47,400 --> 00:39:50,360
이 반대 쪽에서 동일한 동작을 수행 하는데

869
00:39:50,520 --> 00:39:52,920
들어온 메세지를 읽는 거죠

870
00:39:53,200 --> 00:39:56,380
자 이제 reservation-client 도 재시작 하구요

871
00:39:59,720 --> 00:40:02,060
이건 한 7분 정도 걸릴 수 있어요

872
00:40:02,300 --> 00:40:04,580
잠시 기다리시구요

873
00:40:06,100 --> 00:40:09,040
실행하면 짜잔~

874
00:40:09,260 --> 00:40:11,260
좀 더 빨리 진행 해야 겠네요

875
00:40:12,100 --> 00:40:16,740
지금 보시는건 데이터를 읽어 오는 거구요, 문제 없죠 지금은

876
00:40:17,220 --> 00:40:19,220
POST 는 어떨까요. 동작 할까요?

877
00:40:19,400 --> 00:40:23,240
저는 제가 좋아하는 박사님,

878
00:40:23,520 --> 00:40:25,520
아니 4번째로 좋아하는 박사님이 있는데요

879
00:40:26,500 --> 00:40:28,500
메세지를 보낼 건데

880
00:40:28,640 --> 00:40:31,160
4번째로 좋아하는, 보시다 시피 JSON 이구요

881
00:40:31,420 --> 00:40:33,420
이런 body 를 가지고 있어요

882
00:40:33,560 --> 00:40:36,400
제가 4번째로 좋아하는 "누구" 박사님 입니다

883
00:40:36,800 --> 00:40:38,800
4번째요

884
00:40:39,380 --> 00:40:41,380
Send 버튼을 누르면

885
00:40:41,380 --> 00:40:43,320
요기 들어 갔네요

886
00:40:44,040 --> 00:40:47,120
이제 GET, POST 모두 가능한걸 보셨습니다

887
00:40:47,240 --> 00:40:50,000
그런데, 만약 데이터를 보낼 서비스가 없다면 어떻게 될까요

888
00:40:50,220 --> 00:40:52,500
그러면 무슨일이 발생하는지 봅시다. 여기로 가서요

889
00:40:52,920 --> 00:40:54,920
reservation-service 로 가서

890
00:40:54,920 --> 00:40:56,000
KILL

891
00:40:57,300 --> 00:40:59,480
새로 고침을 해보면?

892
00:40:59,500 --> 00:41:01,500
자, 나와야 할 스택 트레이스가 없죠?

893
00:41:01,880 --> 00:41:03,880
대신 비어있는 array list를 받았습니다.

894
00:41:04,040 --> 00:41:06,040
fallback 기억 하시나요?

895
00:41:06,240 --> 00:41:09,800
자, 이 상태에서 제가 가장 좋아하는 3명의 박사님 예약을 POST 해 봅시다

896
00:41:10,620 --> 00:41:13,380
순서는 따로 없구요, 제가 가장 좋아하는 3인

897
00:41:14,960 --> 00:41:16,960
사이어 박사님,

898
00:41:17,840 --> 00:41:19,840
폴락 박사님

899
00:41:22,820 --> 00:41:24,820
수브라 박사님

900
00:41:26,820 --> 00:41:30,140
수-브라-

901
00:41:32,500 --> 00:41:34,500
자, 이건 백엔드가 없을때 서킷 브레이커 fallback 이 GET에 동작한거구요

902
00:41:34,500 --> 00:41:35,960
백엔드가 없는 상태라 저장도 안되야 맞지만,

903
00:41:36,020 --> 00:41:38,020
지금 3개의 레코드는 RabbitMQ에 들어갔을 겁니다.

904
00:41:38,020 --> 00:41:39,880
그래서 reservation-service 를 다시 시작 하면

905
00:41:40,920 --> 00:41:42,920
지금은 동작하지 않는거 보이시죠?

906
00:41:43,340 --> 00:41:46,000
서비스를 시작하면, 메세지가 RabbitMQ에서 서비스로 전달되는걸 볼 수 있어야 합니다.

907
00:41:46,140 --> 00:41:48,760
서비스가 시작되면, 데이터가 들어옵니다.

908
00:41:49,100 --> 00:41:51,100
자 그리고 기억해야 할 것은, 우리 코드에서

909
00:41:51,280 --> 00:41:53,800
6개의 레코드가 메모리 안에 있구요

910
00:41:53,800 --> 00:41:55,600
그래서 "누구" 박사님은 없어졌을 거에요

911
00:41:55,600 --> 00:41:57,220
왜냐면 아까 그 프로세스는 죽였거든요

912
00:41:57,220 --> 00:41:58,780
그래서 '누구' 박사님 데이터는 없죠

913
00:41:58,780 --> 00:41:59,880
자, 됬네요

914
00:42:00,100 --> 00:42:02,440
사이어, 폴락, 수라마니암 박사들 다 있죠?

915
00:42:02,440 --> 00:42:04,400
서비스가 동작하지 않았었는데, 메세지는 전달 되었습니다.

916
00:42:04,740 --> 00:42:07,960
이게 이렇게 동작 할 수 있는건, 설정을 살펴볼 필요가 있어요

917
00:42:11,080 --> 00:42:13,080
자 여기 설정을 보시면

918
00:42:16,220 --> 00:42:18,220
reservation-client 에서는

919
00:42:18,780 --> 00:42:22,100
스프링 클라우드 스트림 바인딩은

920
00:42:23,400 --> 00:42:27,080
스프링 클라우드 스트림 바인딩의 output 목적지는

921
00:42:27,320 --> 00:42:29,320
reservation 이죠

922
00:42:29,460 --> 00:42:31,920
메세지 채널 Output 기억 하시죠?

923
00:42:31,920 --> 00:42:33,920
그게 reservation 입니다.

924
00:42:34,520 --> 00:42:36,920
reservation-service 쪽에서는

925
00:42:36,920 --> 00:42:38,800
동일한걸 반대로 수행하는 부분이 있죠

926
00:42:39,080 --> 00:42:42,200
여기엔 스프링 클라우드 스트림 바인딩, INPUT

927
00:42:43,140 --> 00:42:45,300
이게 reservation 으로 되어 있습니다.

928
00:42:45,360 --> 00:42:47,560
그러니까 이 reservation 이 클라이언트와 서비스의 랑데뷰 포인트가 되는 거에요

929
00:42:47,560 --> 00:42:48,980
프로듀서와 컨슈머,

930
00:42:48,980 --> 00:42:50,200
이게 RabbitMQ안에서

931
00:42:50,200 --> 00:42:51,940
아니면 Kafka나, 아님 다른거

932
00:42:51,940 --> 00:42:53,700
서로 거기서 만나기로 하는 거죠 
[클라이언트와 서비스가 서로 동일한 채널을 사용]

933
00:42:53,700 --> 00:42:54,460
그치만

934
00:42:55,140 --> 00:42:59,420
1:N 의 브로드 캐스트가 아니라 1:1 로 메세지를 보내야 한다고 했죠

935
00:42:59,420 --> 00:43:00,720
그래서 여기 그룹이 있습니다.

936
00:43:00,800 --> 00:43:02,800
이건 컨슈머 그룹이에요

937
00:43:03,320 --> 00:43:05,940
해당 그룹의 단 1개의 인스턴스만 그 메세지를 받도록 합니다

938
00:43:06,000 --> 00:43:10,640
그리고 여기서, 서비스가 동작하지 않더라도 메세지를 전달할 수 있는 옵션이 여기 있습니다.

939
00:43:10,640 --> 00:43:12,200
이걸 durable 이라고 하죠

940
00:43:12,200 --> 00:43:13,360
좋죠?

941
00:43:13,380 --> 00:43:15,380
자 이제 우리는 2분 남았네요

942
00:43:16,000 --> 00:43:19,260
시간이 별로 없으니까, 마지막으로 1개만 더 이야기 할게요

943
00:43:20,860 --> 00:43:25,460
이 전체 시스템에서 메세지가 어떻게 전달 되는지 알고 싶어요

944
00:43:25,460 --> 00:43:27,340
분산 시스템에서는

945
00:43:27,440 --> 00:43:30,720
메세지 하나가 들어오면, 나갈때까지 어떻게 되는지 볼 수 있어야 해요

946
00:43:30,720 --> 00:43:32,480
이걸 "분산 추적" 이라고 부르죠

947
00:43:32,600 --> 00:43:35,240
Zipkin 이라는 트위터에서 만든 도구가 있어요

948
00:43:35,240 --> 00:43:36,480
트위터 아시는 분?

949
00:43:36,680 --> 00:43:39,220
지금은 2016년이죠? 트위터

950
00:43:39,220 --> 00:43:40,720
저도 트위터 사용자구요

951
00:43:40,800 --> 00:43:43,000
그리고 트위터에 있는 제 친구들을 사랑 합니다.

952
00:43:43,140 --> 00:43:45,420
트위터에서 말 걸어 주세요 ㅎㅎ

953
00:43:45,500 --> 00:43:47,780
저도 팔로잉 할게요

954
00:43:48,140 --> 00:43:50,360
여기서 음, Zipkin

955
00:43:51,080 --> 00:43:52,200
Zipkin UI

956
00:43:52,200 --> 00:43:53,700
Zipkin 서버

957
00:43:54,340 --> 00:43:56,340
컨피그 클라이언트

958
00:43:56,480 --> 00:43:58,480
유레카 디스커버리

959
00:43:58,480 --> 00:44:00,120
생성 버튼을 누르구요

960
00:44:00,580 --> 00:44:03,820
이론적으로 분산 추적이라는건 매우 단순합니다.

961
00:44:03,820 --> 00:44:04,820
메세지가 들어오면

962
00:44:04,860 --> 00:44:07,120
여기에 UUID 를 붙이구요

963
00:44:07,240 --> 00:44:12,200
이건 여러개의 시스템간의 요청 메세지를 서로 붙여야 하니까

964
00:44:12,200 --> 00:44:14,080
사실 여태까지 이런건 굉장히 고통스러운 거였죠

965
00:44:14,520 --> 00:44:17,660
다시 이런 작업은 컴퓨터가 하게 해야 합니다.

966
00:44:17,660 --> 00:44:19,620
@EnableZipkinServer

967
00:44:19,780 --> 00:44:23,020
설정 서버 명시해 주구요

968
00:44:24,360 --> 00:44:41,480
[코딩중]

969
00:44:41,580 --> 00:44:45,520
이건 다시 reservation-service 인데요

970
00:44:53,280 --> 00:44:55,280
다시 요청해보면... 자, 모든게 잘 동작 하고 있죠?

971
00:44:55,380 --> 00:44:57,660
이제 분산 추적 도구를 살펴볼건데요

972
00:44:57,760 --> 00:45:01,180
이것도 로컬 호스트의 9411 에

973
00:45:02,020 --> 00:45:04,020
지금 여기 보시면

974
00:45:04,360 --> 00:45:06,580
이 도구는 이미 제가 사용한 요청을 알고 있습니다.

975
00:45:06,580 --> 00:45:08,260
우리 서비스들에 대해 알고 있구요

976
00:45:08,680 --> 00:45:10,680
Zipkin 서버는 이제 막 시작 되었는데도요

977
00:45:11,700 --> 00:45:15,060
Find 버튼을 누르면 1개의 요청에 대한 추적이 보입니다.

978
00:45:15,160 --> 00:45:17,920
다시 몇개의 요청을 수행해 보구요

979
00:45:18,140 --> 00:45:21,500
다시 검색하면, 2개의 추적이 보이네요

980
00:45:21,940 --> 00:45:23,940
예를 들면

981
00:45:23,940 --> 00:45:25,620
이걸 클릭하면

982
00:45:26,220 --> 00:45:28,660
시스템에 메세지가 들어온거

983
00:45:28,760 --> 00:45:31,220
reservations/names 엔드 포인트로 들어온거랑

984
00:45:31,720 --> 00:45:34,640
전체... 다시 좀 더 볼까요

985
00:45:36,540 --> 00:45:38,540
Find 하면 2개가 보이구요

986
00:45:41,440 --> 00:45:45,100
서비스에 요청이 유입되고 이게 처리 되는데 걸린 시간을 보여줍니다

987
00:45:46,020 --> 00:45:49,200
아래로 내려가서 reservation-client 를 보면

988
00:45:49,200 --> 00:45:50,800
여기 부분을 클릭하면

989
00:45:50,840 --> 00:45:54,660
시스템에 요청이 수행된 로그가 남아 있는걸 보실 수 있어요

990
00:45:54,920 --> 00:45:57,400
호스트 정보를 확인할 수 있고

991
00:45:59,220 --> 00:46:02,900
동일한걸 메세지 전달 하는 부분에서도 확인할 수 있습니다.

992
00:46:03,640 --> 00:46:05,640
POST 를 누르고 여기로 돌아가면

993
00:46:07,340 --> 00:46:09,340
Find trace

994
00:46:09,400 --> 00:46:11,620
여기 보시면 하나의 스팬이 있구요 
[전체 추적은 트레이스, 서비스간 요청 추적은 스팬]

995
00:46:11,960 --> 00:46:13,960
여기 보시면 메세지가 (엣지 클라이언트에서) 나가서

996
00:46:13,960 --> 00:46:15,060
(reservation-service 에서) 여기로 들어 오죠

997
00:46:15,760 --> 00:46:18,520
reservation-client 에서 메세지가 나가서

998
00:46:18,520 --> 00:46:19,960
reservation-service 로 가게 되구요

999
00:46:19,960 --> 00:46:21,320
이 사이에

1000
00:46:21,340 --> 00:46:24,180
빈 공간이 있는데요. 바로 이 빈 공간이 RabbitMQ 처리 시간이죠

1001
00:46:24,340 --> 00:46:28,760
이게 바로 시스템에 무슨일이 벌어지고 있는지 살펴보는 하나의 방법이죠

1002
00:46:30,200 --> 00:46:33,120
오늘 많은 내용을 다 소개해 드리지 못해서 미안해요

1003
00:46:33,120 --> 00:46:34,720
저는

1004
00:46:34,720 --> 00:46:36,040
시간이 조금 더 있었다면 
[보통 2시간반에서 3시간 세션]

1005
00:46:36,360 --> 00:46:38,980
아마도 더 자세하게 살펴볼 수 있었을 거에요

1006
00:46:39,280 --> 00:46:40,740
오늘 여러분이 가져갔으면 하는 것은

1007
00:46:40,740 --> 00:46:42,680
제가 지금 했던거 그게 아닙니다.

1008
00:46:42,680 --> 00:46:44,120
그건 제 목적이 아니에요

1009
00:46:44,120 --> 00:46:45,340
여러분께서 이해 했으면 하는 것은

1010
00:46:45,340 --> 00:46:46,720
아키텍처를 구성할때

1011
00:46:46,720 --> 00:46:48,460
특히 분산 환경에서

1012
00:46:48,500 --> 00:46:50,720
우리가 기존에 했던 것과는 아주 달라야 한다는 것이며

1013
00:46:50,720 --> 00:46:52,440
그걸 여러분 혼자 다 만들지 않아도 된다는 것입니다.

1014
00:46:52,440 --> 00:46:53,820
이게 스프링 클라우드 구요

1015
00:46:53,960 --> 00:46:57,720
이건 넷플릭스 사람들과

1016
00:46:57,740 --> 00:47:00,360
트위터, 그리고 스프링 팀들이 함께 개발하고 있는 겁니다

1017
00:47:00,680 --> 00:47:04,560
중요한 도구 먼저 구현을 하고 있구요

1018
00:47:04,880 --> 00:47:06,880
가급적이면 사용하기 쉽도록 만들려고도 노력 합니다

1019
00:47:07,000 --> 00:47:09,880
이런 기능적인 부분이 아닌 것들에 대해서 말이죠

1020
00:47:09,880 --> 00:47:13,700
500줄짜리 '쉬운 따라하기' 위키 페이지 말구요

1021
00:47:13,780 --> 00:47:15,780
그런건 없어져야 합니다

1022
00:47:15,780 --> 00:47:17,360
그런 작업은 저희가 이미 했기 때문이죠

1023
00:47:17,420 --> 00:47:20,600
그래서 여러분들은 확장성 있는 시스템을 빠르게, 반복적으로 개발할 수 있습니다.

1024
00:47:20,860 --> 00:47:23,600
음, 굉장히 훌륭한 사람들이 많은데요

1025
00:47:25,040 --> 00:47:27,040
예, 시간 지난거 알고 있어용

1026
00:47:27,100 --> 00:47:30,100
여기 보시면 가이드가 있구요

1027
00:47:30,260 --> 00:47:32,680
더 자세한 내용은 여기서 얻을 수 있을 겁니다

1028
00:47:32,880 --> 00:47:36,060
들어 주셔서 감사합니다~~

1029
00:47:38,180 --> 00:47:40,180
어하~~

1030
00:47:40,180 --> 00:47:56,140
번역: 정윤진 
yjeong@pivotal.io

